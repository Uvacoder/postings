import {
  Component,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getModularInstance,
  getUA,
  isBrowserExtension,
  isElectron,
  isIE,
  isMobileCordova,
  isReactNative,
  isSafari,
  isUWP,
  registerVersion
} from "./chunk-IQXNA2TK.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm.js
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p2 in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p2))
        d2[p2] = b2[p2];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b = typeof a;
  b = b != "object" ? b : a ? Array.isArray(a) ? "array" : b : "null";
  return b == "array" || b == "object" && typeof a.length == "number";
}
function p(a) {
  var b = typeof a;
  return b == "object" && a != null || b == "function";
}
function da(a) {
  return Object.prototype.hasOwnProperty.call(a, ea) && a[ea] || (a[ea] = ++fa);
}
var ea = "closure_uid_" + (1e9 * Math.random() >>> 0);
var fa = 0;
function ha(a, b, c) {
  return a.call.apply(a.bind, arguments);
}
function ia(a, b, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b, e);
    };
  }
  return function() {
    return a.apply(b, arguments);
  };
}
function q(a, b, c) {
  Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? q = ha : q = ia;
  return q.apply(null, arguments);
}
function ja(a, b) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b) {
  function c() {
  }
  c.prototype = b.prototype;
  a.Z = b.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Vb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ka = 0;
var la = {};
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), ka != 0)) {
    var a = da(this);
    delete la[a];
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var ma = Array.prototype.indexOf ? function(a, b) {
  return Array.prototype.indexOf.call(a, b, void 0);
} : function(a, b) {
  if (typeof a === "string")
    return typeof b !== "string" || b.length != 1 ? -1 : a.indexOf(b, 0);
  for (var c = 0; c < a.length; c++)
    if (c in a && a[c] === b)
      return c;
  return -1;
};
var na = Array.prototype.forEach ? function(a, b, c) {
  Array.prototype.forEach.call(a, b, c);
} : function(a, b, c) {
  var d = a.length, e = typeof a === "string" ? a.split("") : a;
  for (var f = 0; f < d; f++)
    f in e && b.call(c, e[f], f, a);
};
function oa(a) {
  a: {
    var b = pa;
    var c = a.length, d = typeof a === "string" ? a.split("") : a;
    for (var e = 0; e < c; e++)
      if (e in d && b.call(void 0, d[e], e, a)) {
        b = e;
        break a;
      }
    b = -1;
  }
  return 0 > b ? null : typeof a === "string" ? a.charAt(b) : a[b];
}
function qa(a) {
  return Array.prototype.concat.apply([], arguments);
}
function ra(a) {
  var b = a.length;
  if (0 < b) {
    var c = Array(b);
    for (var d = 0; d < b; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function sa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var ta = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function w(a, b) {
  return a.indexOf(b) != -1;
}
function ua(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var x;
a: {
  va2 = l.navigator;
  if (va2) {
    wa2 = va2.userAgent;
    if (wa2) {
      x = wa2;
      break a;
    }
  }
  x = "";
}
var va2;
var wa2;
function xa(a, b, c) {
  for (var d in a)
    b.call(c, a[d], d, a);
}
function ya(a) {
  var b = {};
  for (var c in a)
    b[c] = a[c];
  return b;
}
var za = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Aa(a, b) {
  var c, d;
  for (var e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (var f = 0; f < za.length; f++)
      c = za[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ca(a) {
  Ca[" "](a);
  return a;
}
Ca[" "] = aa;
function Fa(a) {
  var b = Ga;
  return Object.prototype.hasOwnProperty.call(b, 9) ? b[9] : b[9] = a(9);
}
var Ha = w(x, "Opera");
var y = w(x, "Trident") || w(x, "MSIE");
var Ia = w(x, "Edge");
var Ja = Ia || y;
var Ka = w(x, "Gecko") && !(w(x.toLowerCase(), "webkit") && !w(x, "Edge")) && !(w(x, "Trident") || w(x, "MSIE")) && !w(x, "Edge");
var La = w(x.toLowerCase(), "webkit") && !w(x, "Edge");
function Ma() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Na;
a: {
  Oa2 = "", Pa2 = function() {
    var a = x;
    if (Ka)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (Ia)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (La)
      return /WebKit\/(\S+)/.exec(a);
    if (Ha)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Pa2 && (Oa2 = Pa2 ? Pa2[1] : "");
  if (y) {
    Qa2 = Ma();
    if (Qa2 != null && Qa2 > parseFloat(Oa2)) {
      Na = String(Qa2);
      break a;
    }
  }
  Na = Oa2;
}
var Oa2;
var Pa2;
var Qa2;
var Ga = {};
function Ra() {
  return Fa(function() {
    var a = 0;
    var b = ta(String(Na)).split("."), c = ta("9").split("."), d = Math.max(b.length, c.length);
    for (var h = 0; a == 0 && h < d; h++) {
      var e = b[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (e[0].length == 0 && f[0].length == 0)
          break;
        a = ua(e[1].length == 0 ? 0 : parseInt(e[1], 10), f[1].length == 0 ? 0 : parseInt(f[1], 10)) || ua(e[2].length == 0, f[2].length == 0) || ua(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (a == 0);
    }
    return 0 <= a;
  });
}
var Sa;
if (l.document && y) {
  Ta2 = Ma();
  Sa = Ta2 ? Ta2 : parseInt(Na, 10) || void 0;
} else
  Sa = void 0;
var Ta2;
var Ua = Sa;
var Va = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b), l.removeEventListener("test", aa, b);
  } catch (c) {
  }
  return a;
}();
function z(a, b) {
  this.type = a;
  this.g = this.target = b;
  this.defaultPrevented = false;
}
z.prototype.h = function() {
  this.defaultPrevented = true;
};
function A(a, b) {
  z.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b;
    if (b = a.relatedTarget) {
      if (Ka) {
        a: {
          try {
            Ca(b.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b = null);
      }
    } else
      c == "mouseover" ? b = a.fromElement : c == "mouseout" && (b = a.toElement);
    this.relatedTarget = b;
    d ? (this.clientX = d.clientX !== void 0 ? d.clientX : d.pageX, this.clientY = d.clientY !== void 0 ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = a.clientX !== void 0 ? a.clientX : a.pageX, this.clientY = a.clientY !== void 0 ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = typeof a.pointerType === "string" ? a.pointerType : Wa[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && A.Z.h.call(this);
  }
}
t(A, z);
var Wa = { 2: "touch", 3: "pen", 4: "mouse" };
A.prototype.h = function() {
  A.Z.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var B = "closure_listenable_" + (1e6 * Math.random() | 0);
var Xa = 0;
function Ya(a, b, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b;
  this.type = c;
  this.capture = !!d;
  this.ia = e;
  this.key = ++Xa;
  this.ca = this.fa = false;
}
function Za(a) {
  a.ca = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ia = null;
}
function $a(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
$a.prototype.add = function(a, b, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = ab(a, b, d, e);
  -1 < h ? (b = a[h], c || (b.fa = false)) : (b = new Ya(b, this.src, f, !!d, e), b.fa = c, a.push(b));
  return b;
};
function bb(a, b) {
  var c = b.type;
  if (c in a.g) {
    var d = a.g[c], e = ma(d, b), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Za(b), a.g[c].length == 0 && (delete a.g[c], a.h--));
  }
}
function ab(a, b, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ca && f.listener == b && f.capture == !!c && f.ia == d)
      return e;
  }
  return -1;
}
var cb = "closure_lm_" + (1e6 * Math.random() | 0);
var db = {};
function fb(a, b, c, d, e) {
  if (d && d.once)
    return gb(a, b, c, d, e);
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      fb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.N(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, false, d, e);
}
function ib(a, b, c, d, e, f) {
  if (!b)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = jb(a);
  n || (a[cb] = n = new $a(a));
  c = n.add(b, c, d, h, f);
  if (c.proxy)
    return c;
  d = kb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    Va || (e = h), e === void 0 && (e = false), a.addEventListener(b.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(lb(b.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function kb() {
  function a(c) {
    return b.call(a.src, a.listener, c);
  }
  var b = mb;
  return a;
}
function gb(a, b, c, d, e) {
  if (Array.isArray(b)) {
    for (var f = 0; f < b.length; f++)
      gb(a, b[f], c, d, e);
    return null;
  }
  c = hb(c);
  return a && a[B] ? a.O(b, c, p(d) ? !!d.capture : !!d, e) : ib(a, b, c, true, d, e);
}
function nb(a, b, c, d, e) {
  if (Array.isArray(b))
    for (var f = 0; f < b.length; f++)
      nb(a, b[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = hb(c), a && a[B]) ? (a = a.i, b = String(b).toString(), b in a.g && (f = a.g[b], c = ab(f, c, d, e), -1 < c && (Za(f[c]), Array.prototype.splice.call(f, c, 1), f.length == 0 && (delete a.g[b], a.h--)))) : a && (a = jb(a)) && (b = a.g[b.toString()], a = -1, b && (a = ab(b, c, d, e)), (c = -1 < a ? b[a] : null) && ob(c));
}
function ob(a) {
  if (typeof a !== "number" && a && !a.ca) {
    var b = a.src;
    if (b && b[B])
      bb(b.i, a);
    else {
      var c = a.type, d = a.proxy;
      b.removeEventListener ? b.removeEventListener(c, d, a.capture) : b.detachEvent ? b.detachEvent(lb(c), d) : b.addListener && b.removeListener && b.removeListener(d);
      (c = jb(b)) ? (bb(c, a), c.h == 0 && (c.src = null, b[cb] = null)) : Za(a);
    }
  }
}
function lb(a) {
  return a in db ? db[a] : db[a] = "on" + a;
}
function mb(a, b) {
  if (a.ca)
    a = true;
  else {
    b = new A(b, this);
    var c = a.listener, d = a.ia || a.src;
    a.fa && ob(a);
    a = c.call(d, b);
  }
  return a;
}
function jb(a) {
  a = a[cb];
  return a instanceof $a ? a : null;
}
var pb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function hb(a) {
  if (typeof a === "function")
    return a;
  a[pb] || (a[pb] = function(b) {
    return a.handleEvent(b);
  });
  return a[pb];
}
function C() {
  v.call(this);
  this.i = new $a(this);
  this.P = this;
  this.I = null;
}
t(C, v);
C.prototype[B] = true;
C.prototype.removeEventListener = function(a, b, c, d) {
  nb(this, a, b, c, d);
};
function D(a, b) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b.type || b;
  if (typeof b === "string")
    b = new z(b, a);
  else if (b instanceof z)
    b.target = b.target || a;
  else {
    var e = b;
    b = new z(d, a);
    Aa(b, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b.g = c[f];
      e = qb(h, d, true, b) && e;
    }
  h = b.g = a;
  e = qb(h, d, true, b) && e;
  e = qb(h, d, false, b) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b.g = c[f], e = qb(h, d, false, b) && e;
}
C.prototype.M = function() {
  C.Z.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Za(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
C.prototype.N = function(a, b, c, d) {
  return this.i.add(String(a), b, false, c, d);
};
C.prototype.O = function(a, b, c, d) {
  return this.i.add(String(a), b, true, c, d);
};
function qb(a, b, c, d) {
  b = a.i.g[String(b)];
  if (!b)
    return true;
  b = b.concat();
  for (var e = true, f = 0; f < b.length; ++f) {
    var h = b[f];
    if (h && !h.ca && h.capture == c) {
      var n = h.listener, u = h.ia || h.src;
      h.fa && bb(a.i, h);
      e = n.call(u, d) !== false && e;
    }
  }
  return e && !d.defaultPrevented;
}
var rb = l.JSON.stringify;
function sb() {
  var a = tb;
  var b = null;
  a.g && (b = a.g, a.g = a.g.next, a.g || (a.h = null), b.next = null);
  return b;
}
var ub = function() {
  function ub2() {
    this.h = this.g = null;
  }
  ub2.prototype.add = function(a, b) {
    var c = vb.get();
    c.set(a, b);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  };
  return ub2;
}();
var vb = new (function() {
  function class_2(a, b) {
    this.i = a;
    this.j = b;
    this.h = 0;
    this.g = null;
  }
  class_2.prototype.get = function() {
    var a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  };
  return class_2;
}())(function() {
  return new wb();
}, function(a) {
  return a.reset();
});
var wb = function() {
  function wb2() {
    this.next = this.g = this.h = null;
  }
  wb2.prototype.set = function(a, b) {
    this.h = a;
    this.g = b;
    this.next = null;
  };
  wb2.prototype.reset = function() {
    this.next = this.g = this.h = null;
  };
  return wb2;
}();
function yb(a) {
  l.setTimeout(function() {
    throw a;
  }, 0);
}
function zb(a, b) {
  Ab || Bb();
  Cb || (Ab(), Cb = true);
  tb.add(a, b);
}
var Ab;
function Bb() {
  var a = l.Promise.resolve(void 0);
  Ab = function() {
    a.then(Db);
  };
}
var Cb = false;
var tb = new ub();
function Db() {
  for (var a; a = sb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      yb(c);
    }
    var b = vb;
    b.j(a);
    100 > b.h && (b.h++, a.next = b.g, b.g = a);
  }
  Cb = false;
}
function Eb(a, b) {
  C.call(this);
  this.h = a || 1;
  this.g = b || l;
  this.j = q(this.kb, this);
  this.l = Date.now();
}
t(Eb, C);
k = Eb.prototype;
k.da = false;
k.S = null;
k.kb = function() {
  if (this.da) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.S = this.g.setTimeout(this.j, this.h - a) : (this.S && (this.g.clearTimeout(this.S), this.S = null), D(this, "tick"), this.da && (Fb(this), this.start()));
  }
};
k.start = function() {
  this.da = true;
  this.S || (this.S = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function Fb(a) {
  a.da = false;
  a.S && (a.g.clearTimeout(a.S), a.S = null);
}
k.M = function() {
  Eb.Z.M.call(this);
  Fb(this);
  delete this.g;
};
function Gb(a, b, c) {
  if (typeof a === "function")
    c && (a = q(a, c));
  else if (a && typeof a.handleEvent == "function")
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b) ? -1 : l.setTimeout(a, b || 0);
}
function Hb(a) {
  a.g = Gb(function() {
    a.g = null;
    a.i && (a.i = false, Hb(a));
  }, a.j);
  var b = a.h;
  a.h = null;
  a.m.apply(null, b);
}
var Ib = function(_super) {
  __extends(Ib2, _super);
  function Ib2(a, b) {
    var _this = _super.call(this) || this;
    _this.m = a;
    _this.j = b;
    _this.h = null;
    _this.i = false;
    _this.g = null;
    return _this;
  }
  Ib2.prototype.l = function(a) {
    this.h = arguments;
    this.g ? this.i = true : Hb(this);
  };
  Ib2.prototype.M = function() {
    _super.prototype.M.call(this);
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  };
  return Ib2;
}(v);
function E(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(E, v);
var Jb = [];
function Kb(a, b, c, d) {
  Array.isArray(c) || (c && (Jb[0] = c.toString()), c = Jb);
  for (var e = 0; e < c.length; e++) {
    var f = fb(b, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Lb(a) {
  xa(a.g, function(b, c) {
    this.g.hasOwnProperty(c) && ob(b);
  }, a);
  a.g = {};
}
E.prototype.M = function() {
  E.Z.M.call(this);
  Lb(this);
};
E.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Mb() {
  this.g = true;
}
Mb.prototype.Aa = function() {
  this.g = false;
};
function Nb(a, b, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var G2 = r.split("_");
            h = 2 <= G2.length && G2[1] == "type" ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b + "\n" + c + "\n" + h;
  });
}
function Ob(a, b, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b + "\n" + c + "\n" + f + " " + h;
  });
}
function F(a, b, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b + "): " + Pb(a, c) + (d ? " " + d : "");
  });
}
function Qb(a, b) {
  a.info(function() {
    return "TIMEOUT: " + b;
  });
}
Mb.prototype.info = function() {
};
function Pb(a, b) {
  if (!a.g)
    return b;
  if (!b)
    return null;
  try {
    var c = JSON.parse(b);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if (f != "noop" && f != "stop" && f != "close")
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return rb(c);
  } catch (n) {
    return b;
  }
}
var H = {};
var Rb = null;
function Sb() {
  return Rb = Rb || new C();
}
H.Ma = "serverreachability";
function Tb(a) {
  z.call(this, H.Ma, a);
}
t(Tb, z);
function I(a) {
  var b = Sb();
  D(b, new Tb(b, a));
}
H.STAT_EVENT = "statevent";
function Ub(a, b) {
  z.call(this, H.STAT_EVENT, a);
  this.stat = b;
}
t(Ub, z);
function J(a) {
  var b = Sb();
  D(b, new Ub(b, a));
}
H.Na = "timingevent";
function Vb(a, b) {
  z.call(this, H.Na, a);
  this.size = b;
}
t(Vb, z);
function K(a, b) {
  if (typeof a !== "function")
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b);
}
var Wb = { NO_ERROR: 0, lb: 1, yb: 2, xb: 3, sb: 4, wb: 5, zb: 6, Ja: 7, TIMEOUT: 8, Cb: 9 };
var Xb = { qb: "complete", Mb: "success", Ka: "error", Ja: "abort", Eb: "ready", Fb: "readystatechange", TIMEOUT: "timeout", Ab: "incrementaldata", Db: "progress", tb: "downloadprogress", Ub: "uploadprogress" };
function Yb() {
}
Yb.prototype.h = null;
function Zb(a) {
  return a.h || (a.h = a.i());
}
function $b() {
}
var L = { OPEN: "a", pb: "b", Ka: "c", Bb: "d" };
function ac() {
  z.call(this, "d");
}
t(ac, z);
function bc() {
  z.call(this, "c");
}
t(bc, z);
var cc;
function dc() {
}
t(dc, Yb);
dc.prototype.g = function() {
  return new XMLHttpRequest();
};
dc.prototype.i = function() {
  return {};
};
cc = new dc();
function M(a, b, c, d) {
  this.l = a;
  this.j = b;
  this.m = c;
  this.X = d || 1;
  this.V = new E(this);
  this.P = ec;
  a = Ja ? 125 : void 0;
  this.W = new Eb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.Y = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.N = -1;
  this.I = false;
  this.O = 0;
  this.L = null;
  this.aa = this.J = this.$ = this.U = false;
  this.h = new fc();
}
function fc() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var ec = 45e3;
var gc = {};
var hc = {};
k = M.prototype;
k.setTimeout = function(a) {
  this.P = a;
};
function ic(a, b, c) {
  a.K = 1;
  a.v = jc(N(b));
  a.s = c;
  a.U = true;
  kc(a, null);
}
function kc(a, b) {
  a.F = Date.now();
  lc(a);
  a.A = N(a.v);
  var c = a.A, d = a.X;
  Array.isArray(d) || (d = [String(d)]);
  mc(c.h, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new fc();
  a.g = nc(a.l, c ? b : null, !a.s);
  0 < a.O && (a.L = new Ib(q(a.Ia, a, a.g), a.O));
  Kb(a.V, a.g, "readystatechange", a.gb);
  b = a.H ? ya(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b["Content-Type"] = "application/x-www-form-urlencoded", a.g.ea(a.A, a.u, a.s, b)) : (a.u = "GET", a.g.ea(a.A, a.u, null, b));
  I(1);
  Nb(a.j, a.u, a.A, a.m, a.X, a.s);
}
k.gb = function(a) {
  a = a.target;
  var b = this.L;
  b && O(a) == 3 ? b.l() : this.Ia(a);
};
k.Ia = function(a) {
  try {
    if (a == this.g)
      a: {
        var r = O(this.g);
        var b = this.g.Da();
        var G2 = this.g.ba();
        if (!(3 > r) && (r != 3 || Ja || this.g && (this.h.h || this.g.ga() || oc(this.g)))) {
          this.I || r != 4 || b == 7 || (b == 8 || 0 >= G2 ? I(3) : I(2));
          pc(this);
          var c = this.g.ba();
          this.N = c;
          b:
            if (qc(this)) {
              var d = oc(this.g);
              a = "";
              var e = d.length, f = O(this.g) == 4;
              if (!this.h.i) {
                if (typeof TextDecoder === "undefined") {
                  P(this);
                  rc(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b = 0; b < e; b++)
                this.h.h = true, a += this.h.i.decode(d[b], { stream: f && b == e - 1 });
              d.splice(0, e);
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.ga();
          this.i = c == 200;
          Ob(this.j, this.u, this.A, this.m, this.X, r, c);
          if (this.i) {
            if (this.$ && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !sa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                F(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, sc(this, c);
              else {
                this.i = false;
                this.o = 3;
                J(12);
                P(this);
                rc(this);
                break a;
              }
            }
            this.U ? (tc(this, r, h), Ja && this.i && r == 3 && (Kb(this.V, this.W, "tick", this.fb), this.W.start())) : (F(this.j, this.m, h, null), sc(this, h));
            r == 4 && P(this);
            this.i && !this.I && (r == 4 ? uc(this.l, this) : (this.i = false, lc(this)));
          } else
            c == 400 && 0 < h.indexOf("Unknown SID") ? (this.o = 3, J(12)) : (this.o = 0, J(13)), P(this), rc(this);
        }
      }
  } catch (r2) {
  } finally {
  }
};
function qc(a) {
  return a.g ? a.u == "GET" && a.K != 2 && a.l.Ba : false;
}
function tc(a, b, c) {
  var d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = vc(a, c), e == hc) {
      b == 4 && (a.o = 4, J(14), d = false);
      F(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == gc) {
      a.o = 4;
      J(15);
      F(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      F(a.j, a.m, e, null), sc(a, e);
  qc(a) && e != hc && e != gc && (a.h.g = "", a.C = 0);
  b != 4 || c.length != 0 || a.h.h || (a.o = 1, J(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.aa && (a.aa = true, b = a.l, b.g == a && b.$ && !b.L && (b.h.info("Great, no buffering proxy detected. Bytes received: " + c.length), wc(b), b.L = true, J(11))) : (F(a.j, a.m, c, "[Invalid Chunked Response]"), P(a), rc(a));
}
k.fb = function() {
  if (this.g) {
    var a = O(this.g), b = this.g.ga();
    this.C < b.length && (pc(this), tc(this, a, b), this.i && a != 4 && lc(this));
  }
};
function vc(a, b) {
  var c = a.C, d = b.indexOf("\n", c);
  if (d == -1)
    return hc;
  c = Number(b.substring(c, d));
  if (isNaN(c))
    return gc;
  d += 1;
  if (d + c > b.length)
    return hc;
  b = b.substr(d, c);
  a.C = d + c;
  return b;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function lc(a) {
  a.Y = Date.now() + a.P;
  xc(a, a.P);
}
function xc(a, b) {
  if (a.B != null)
    throw Error("WatchDog timer not null");
  a.B = K(q(a.eb, a), b);
}
function pc(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.eb = function() {
  this.B = null;
  var a = Date.now();
  0 <= a - this.Y ? (Qb(this.j, this.A), this.K != 2 && (I(3), J(17)), P(this), this.o = 2, rc(this)) : xc(this, this.Y - a);
};
function rc(a) {
  a.l.G == 0 || a.I || uc(a.l, a);
}
function P(a) {
  pc(a);
  var b = a.L;
  b && typeof b.na == "function" && b.na();
  a.L = null;
  Fb(a.W);
  Lb(a.V);
  a.g && (b = a.g, a.g = null, b.abort(), b.na());
}
function sc(a, b) {
  try {
    var c = a.l;
    if (c.G != 0 && (c.g == a || yc(c.i, a))) {
      if (c.I = a.N, !a.J && yc(c.i, a) && c.G == 3) {
        try {
          var d = c.Ca.g.parse(b);
        } catch (m2) {
          d = null;
        }
        if (Array.isArray(d) && d.length == 3) {
          var e = d;
          if (e[0] == 0)
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    zc(c), Ac(c);
                  else
                    break a;
                Bc(c);
                J(18);
              }
            }
          else
            c.ta = e[1], 0 < c.ta - c.U && 37500 > e[2] && c.N && c.A == 0 && !c.v && (c.v = K(q(c.ab, c), 6e3));
          if (1 >= Cc(c.i) && c.ka) {
            try {
              c.ka();
            } catch (m2) {
            }
            c.ka = void 0;
          }
        } else
          Q(c, 11);
      } else if ((a.J || c.g == a) && zc(c), !sa(b))
        for (e = c.Ca.g.parse(b), b = 0; b < e.length; b++) {
          var m = e[b];
          c.U = m[0];
          m = m[1];
          if (c.G == 2)
            if (m[0] == "c") {
              c.J = m[1];
              c.la = m[2];
              var r = m[3];
              r != null && (c.ma = r, c.h.info("VER=" + c.ma));
              var G2 = m[4];
              G2 != null && (c.za = G2, c.h.info("SVER=" + c.za));
              var Da2 = m[5];
              Da2 != null && typeof Da2 === "number" && 0 < Da2 && (d = 1.5 * Da2, c.K = d, c.h.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              var ca2 = a.g;
              if (ca2) {
                var Ea2 = ca2.g ? ca2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Ea2) {
                  var f = d.i;
                  !f.g && (w(Ea2, "spdy") || w(Ea2, "quic") || w(Ea2, "h2")) && (f.j = f.l, f.g = new Set(), f.h && (Dc(f, f.h), f.h = null));
                }
                if (d.D) {
                  var xb = ca2.g ? ca2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  xb && (d.sa = xb, R(d.F, d.D, xb));
                }
              }
              c.G = 3;
              c.j && c.j.xa();
              c.$ && (c.O = Date.now() - a.F, c.h.info("Handshake RTT: " + c.O + "ms"));
              d = c;
              var h = a;
              d.oa = Ec(d, d.H ? d.la : null, d.W);
              if (h.J) {
                Fc(d.i, h);
                var n = h, u = d.K;
                u && n.setTimeout(u);
                n.B && (pc(n), lc(n));
                d.g = h;
              } else
                Gc(d);
              0 < c.l.length && Hc(c);
            } else
              m[0] != "stop" && m[0] != "close" || Q(c, 7);
          else
            c.G == 3 && (m[0] == "stop" || m[0] == "close" ? m[0] == "stop" ? Q(c, 7) : Ic(c) : m[0] != "noop" && c.j && c.j.wa(m), c.A = 0);
        }
    }
    I(4);
  } catch (m2) {
  }
}
function Jc(a) {
  if (a.R && typeof a.R == "function")
    return a.R();
  if (typeof a === "string")
    return a.split("");
  if (ba(a)) {
    for (var b = [], c = a.length, d = 0; d < c; d++)
      b.push(a[d]);
    return b;
  }
  b = [];
  c = 0;
  for (d in a)
    b[c++] = a[d];
  return b;
}
function Kc(a, b) {
  if (a.forEach && typeof a.forEach == "function")
    a.forEach(b, void 0);
  else if (ba(a) || typeof a === "string")
    na(a, b, void 0);
  else {
    if (a.T && typeof a.T == "function")
      var c = a.T();
    else if (a.R && typeof a.R == "function")
      c = void 0;
    else if (ba(a) || typeof a === "string") {
      c = [];
      for (var d = a.length, e = 0; e < d; e++)
        c.push(e);
    } else
      for (e in c = [], d = 0, a)
        c[d++] = e;
    d = Jc(a);
    e = d.length;
    for (var f = 0; f < e; f++)
      b.call(void 0, d[f], c && c[f], a);
  }
}
function S(a, b) {
  this.h = {};
  this.g = [];
  this.i = 0;
  var c = arguments.length;
  if (1 < c) {
    if (c % 2)
      throw Error("Uneven number of arguments");
    for (var d = 0; d < c; d += 2)
      this.set(arguments[d], arguments[d + 1]);
  } else if (a)
    if (a instanceof S)
      for (c = a.T(), d = 0; d < c.length; d++)
        this.set(c[d], a.get(c[d]));
    else
      for (d in a)
        this.set(d, a[d]);
}
k = S.prototype;
k.R = function() {
  Lc(this);
  for (var a = [], b = 0; b < this.g.length; b++)
    a.push(this.h[this.g[b]]);
  return a;
};
k.T = function() {
  Lc(this);
  return this.g.concat();
};
function Lc(a) {
  if (a.i != a.g.length) {
    for (var b = 0, c = 0; b < a.g.length; ) {
      var d = a.g[b];
      T(a.h, d) && (a.g[c++] = d);
      b++;
    }
    a.g.length = c;
  }
  if (a.i != a.g.length) {
    var e = {};
    for (c = b = 0; b < a.g.length; )
      d = a.g[b], T(e, d) || (a.g[c++] = d, e[d] = 1), b++;
    a.g.length = c;
  }
}
k.get = function(a, b) {
  return T(this.h, a) ? this.h[a] : b;
};
k.set = function(a, b) {
  T(this.h, a) || (this.i++, this.g.push(a));
  this.h[a] = b;
};
k.forEach = function(a, b) {
  for (var c = this.T(), d = 0; d < c.length; d++) {
    var e = c[d], f = this.get(e);
    a.call(b, f, e, this);
  }
};
function T(a, b) {
  return Object.prototype.hasOwnProperty.call(a, b);
}
var Mc = /^(?:([^:/?#.]+):)?(?:\/\/(?:([^\\/?#]*)@)?([^\\/?#]*?)(?::([0-9]+))?(?=[\\/?#]|$))?([^?#]+)?(?:\?([^#]*))?(?:#([\s\S]*))?$/;
function Nc(a, b) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function U(a, b) {
  this.i = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.g = false;
  if (a instanceof U) {
    this.g = b !== void 0 ? b : a.g;
    Oc(this, a.j);
    this.s = a.s;
    Pc(this, a.i);
    Qc(this, a.m);
    this.l = a.l;
    b = a.h;
    var c = new Rc();
    c.i = b.i;
    b.g && (c.g = new S(b.g), c.h = b.h);
    Sc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Mc)) ? (this.g = !!b, Oc(this, c[1] || "", true), this.s = Tc(c[2] || ""), Pc(this, c[3] || "", true), Qc(this, c[4]), this.l = Tc(c[5] || "", true), Sc(this, c[6] || "", true), this.o = Tc(c[7] || "")) : (this.g = !!b, this.h = new Rc(null, this.g));
}
U.prototype.toString = function() {
  var a = [], b = this.j;
  b && a.push(Uc(b, Vc, true), ":");
  var c = this.i;
  if (c || b == "file")
    a.push("//"), (b = this.s) && a.push(Uc(b, Vc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, c != null && a.push(":", String(c));
  if (c = this.l)
    this.i && c.charAt(0) != "/" && a.push("/"), a.push(Uc(c, c.charAt(0) == "/" ? Wc : Xc, true));
  (c = this.h.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Uc(c, Yc));
  return a.join("");
};
function N(a) {
  return new U(a);
}
function Oc(a, b, c) {
  a.j = c ? Tc(b, true) : b;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Pc(a, b, c) {
  a.i = c ? Tc(b, true) : b;
}
function Qc(a, b) {
  if (b) {
    b = Number(b);
    if (isNaN(b) || 0 > b)
      throw Error("Bad port number " + b);
    a.m = b;
  } else
    a.m = null;
}
function Sc(a, b, c) {
  b instanceof Rc ? (a.h = b, Zc(a.h, a.g)) : (c || (b = Uc(b, $c)), a.h = new Rc(b, a.g));
}
function R(a, b, c) {
  a.h.set(b, c);
}
function jc(a) {
  R(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function ad(a) {
  return a instanceof U ? N(a) : new U(a, void 0);
}
function bd(a, b, c, d) {
  var e = new U(null, void 0);
  a && Oc(e, a);
  b && Pc(e, b);
  c && Qc(e, c);
  d && (e.l = d);
  return e;
}
function Tc(a, b) {
  return a ? b ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Uc(a, b, c) {
  return typeof a === "string" ? (a = encodeURI(a).replace(b, cd), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function cd(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Vc = /[#\/\?@]/g;
var Xc = /[#\?:]/g;
var Wc = /[#\?]/g;
var $c = /[#\?@]/g;
var Yc = /#/g;
function Rc(a, b) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b;
}
function V(a) {
  a.g || (a.g = new S(), a.h = 0, a.i && Nc(a.i, function(b, c) {
    a.add(decodeURIComponent(b.replace(/\+/g, " ")), c);
  }));
}
k = Rc.prototype;
k.add = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b);
  this.h += 1;
  return this;
};
function dd(a, b) {
  V(a);
  b = W(a, b);
  T(a.g.h, b) && (a.i = null, a.h -= a.g.get(b).length, a = a.g, T(a.h, b) && (delete a.h[b], a.i--, a.g.length > 2 * a.i && Lc(a)));
}
function ed(a, b) {
  V(a);
  b = W(a, b);
  return T(a.g.h, b);
}
k.forEach = function(a, b) {
  V(this);
  this.g.forEach(function(c, d) {
    na(c, function(e) {
      a.call(b, e, d, this);
    }, this);
  }, this);
};
k.T = function() {
  V(this);
  for (var a = this.g.R(), b = this.g.T(), c = [], d = 0; d < b.length; d++)
    for (var e = a[d], f = 0; f < e.length; f++)
      c.push(b[d]);
  return c;
};
k.R = function(a) {
  V(this);
  var b = [];
  if (typeof a === "string")
    ed(this, a) && (b = qa(b, this.g.get(W(this, a))));
  else {
    a = this.g.R();
    for (var c = 0; c < a.length; c++)
      b = qa(b, a[c]);
  }
  return b;
};
k.set = function(a, b) {
  V(this);
  this.i = null;
  a = W(this, a);
  ed(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b]);
  this.h += 1;
  return this;
};
k.get = function(a, b) {
  if (!a)
    return b;
  a = this.R(a);
  return 0 < a.length ? String(a[0]) : b;
};
function mc(a, b, c) {
  dd(a, b);
  0 < c.length && (a.i = null, a.g.set(W(a, b), ra(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  for (var a = [], b = this.g.T(), c = 0; c < b.length; c++) {
    var d = b[c], e = encodeURIComponent(String(d));
    d = this.R(d);
    for (var f = 0; f < d.length; f++) {
      var h = e;
      d[f] !== "" && (h += "=" + encodeURIComponent(String(d[f])));
      a.push(h);
    }
  }
  return this.i = a.join("&");
};
function W(a, b) {
  b = String(b);
  a.j && (b = b.toLowerCase());
  return b;
}
function Zc(a, b) {
  b && !a.j && (V(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (dd(this, d), mc(this, e, c));
  }, a));
  a.j = b;
}
var fd = function() {
  function fd2(a, b) {
    this.h = a;
    this.g = b;
  }
  return fd2;
}();
function gd(a) {
  this.l = a || hd;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && (a[0].nextHopProtocol == "hq" || a[0].nextHopProtocol == "h2")) : a = !!(l.g && l.g.Ea && l.g.Ea() && l.g.Ea().Zb);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = new Set());
  this.h = null;
  this.i = [];
}
var hd = 10;
function id(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function Cc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function yc(a, b) {
  return a.h ? a.h == b : a.g ? a.g.has(b) : false;
}
function Dc(a, b) {
  a.g ? a.g.add(b) : a.h = b;
}
function Fc(a, b) {
  a.h && a.h == b ? a.h = null : a.g && a.g.has(b) && a.g.delete(b);
}
gd.prototype.cancel = function() {
  var e_1, _a2;
  this.i = jd(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && this.g.size !== 0) {
    try {
      for (var _b = __values(this.g.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var a = _c2.value;
        a.cancel();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    this.g.clear();
  }
};
function jd(a) {
  var e_2, _a2;
  if (a.h != null)
    return a.i.concat(a.h.D);
  if (a.g != null && a.g.size !== 0) {
    var b = a.i;
    try {
      for (var _b = __values(a.g.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
        var c = _c2.value;
        b = b.concat(c.D);
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c2 && !_c2.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_2)
          throw e_2.error;
      }
    }
    return b;
  }
  return ra(a.i);
}
function kd() {
}
kd.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
kd.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ld() {
  this.g = new kd();
}
function md(a, b, c) {
  var d = c || "";
  try {
    Kc(a, function(e, f) {
      var h = e;
      p(e) && (h = rb(e));
      b.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function nd(a, b) {
  var c = new Mb();
  if (l.Image) {
    var d_1 = new Image();
    d_1.onload = ja(od, c, d_1, "TestLoadImage: loaded", true, b);
    d_1.onerror = ja(od, c, d_1, "TestLoadImage: error", false, b);
    d_1.onabort = ja(od, c, d_1, "TestLoadImage: abort", false, b);
    d_1.ontimeout = ja(od, c, d_1, "TestLoadImage: timeout", false, b);
    l.setTimeout(function() {
      if (d_1.ontimeout)
        d_1.ontimeout();
    }, 1e4);
    d_1.src = a;
  } else
    b(false);
}
function od(a, b, c, d, e) {
  try {
    b.onload = null, b.onerror = null, b.onabort = null, b.ontimeout = null, e(d);
  } catch (f) {
  }
}
function pd(a) {
  this.l = a.$b || null;
  this.j = a.ib || false;
}
t(pd, Yb);
pd.prototype.g = function() {
  return new qd(this.l, this.j);
};
pd.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function qd(a, b) {
  C.call(this);
  this.D = a;
  this.u = b;
  this.m = void 0;
  this.readyState = rd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(qd, C);
var rd = 0;
k = qd.prototype;
k.open = function(a, b) {
  if (this.readyState != rd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b;
  this.readyState = 1;
  sd(this);
};
k.send = function(a) {
  if (this.readyState != 1)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  var b = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b.body = a);
  (this.D || l).fetch(new Request(this.B, b)).then(this.Va.bind(this), this.ha.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.");
  1 <= this.readyState && this.g && this.readyState != 4 && (this.g = false, td(this));
  this.readyState = rd;
};
k.Va = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, sd(this)), this.g && (this.readyState = 3, sd(this), this.g)))
    if (this.responseType === "arraybuffer")
      a.arrayBuffer().then(this.Ta.bind(this), this.ha.bind(this));
    else if (typeof l.ReadableStream !== "undefined" && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      ud(this);
    } else
      a.text().then(this.Ua.bind(this), this.ha.bind(this));
};
function ud(a) {
  a.j.read().then(a.Sa.bind(a)).catch(a.ha.bind(a));
}
k.Sa = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b = a.value ? a.value : new Uint8Array(0);
      if (b = this.A.decode(b, { stream: !a.done }))
        this.response = this.responseText += b;
    }
    a.done ? td(this) : sd(this);
    this.readyState == 3 && ud(this);
  }
};
k.Ua = function(a) {
  this.g && (this.response = this.responseText = a, td(this));
};
k.Ta = function(a) {
  this.g && (this.response = a, td(this));
};
k.ha = function() {
  this.g && td(this);
};
function td(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  sd(a);
}
k.setRequestHeader = function(a, b) {
  this.v.append(a, b);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  var a = [], b = this.h.entries();
  for (var c = b.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b.next();
  return a.join("\r\n");
};
function sd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(qd.prototype, "withCredentials", { get: function() {
  return this.m === "include";
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var vd = l.JSON.parse;
function X(a) {
  C.call(this);
  this.headers = new S();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = wd;
  this.K = this.L = false;
}
t(X, C);
var wd = "";
var xd = /^https?$/i;
var yd = ["POST", "PUT"];
k = X.prototype;
k.ea = function(a, b, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b = b ? b.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : cc.g();
  this.C = this.u ? Zb(this.u) : Zb(cc);
  this.g.onreadystatechange = q(this.Fa, this);
  try {
    this.F = true, this.g.open(b, String(a), true), this.F = false;
  } catch (f) {
    zd(this, f);
    return;
  }
  a = c || "";
  var e = new S(this.headers);
  d && Kc(d, function(f, h) {
    e.set(h, f);
  });
  d = oa(e.T());
  c = l.FormData && a instanceof l.FormData;
  !(0 <= ma(yd, b)) || d || c || e.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  e.forEach(function(f, h) {
    this.g.setRequestHeader(h, f);
  }, this);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    Ad(this), 0 < this.B && ((this.K = Bd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.pa, this)) : this.A = Gb(this.pa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    zd(this, f);
  }
};
function Bd(a) {
  return y && Ra() && typeof a.timeout === "number" && a.ontimeout !== void 0;
}
function pa(a) {
  return a.toLowerCase() == "content-type";
}
k.pa = function() {
  typeof goog != "undefined" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, D(this, "timeout"), this.abort(8));
};
function zd(a, b) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b;
  a.m = 5;
  Cd(a);
  Dd(a);
}
function Cd(a) {
  a.D || (a.D = true, D(a, "complete"), D(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, D(this, "complete"), D(this, "abort"), Dd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), Dd(this, true));
  X.Z.M.call(this);
};
k.Fa = function() {
  this.s || (this.F || this.v || this.l ? Ed(this) : this.cb());
};
k.cb = function() {
  Ed(this);
};
function Ed(a) {
  if (a.h && typeof goog != "undefined" && (!a.C[1] || O(a) != 4 || a.ba() != 2)) {
    if (a.v && O(a) == 4)
      Gb(a.Fa, 0, a);
    else if (D(a, "readystatechange"), O(a) == 4) {
      a.h = false;
      try {
        var n = a.ba();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b = true;
              break a;
            default:
              b = false;
          }
        var c;
        if (!(c = b)) {
          var d;
          if (d = n === 0) {
            var e = String(a.H).match(Mc)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !xd.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          D(a, "complete"), D(a, "success");
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.ba() + "]";
          Cd(a);
        }
      } finally {
        Dd(a);
      }
    }
  }
}
function Dd(a, b) {
  if (a.g) {
    Ad(a);
    var c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b || D(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function Ad(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.ba = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.ga = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Qa = function(a) {
  if (this.g) {
    var b = this.g.responseText;
    a && b.indexOf(a) == 0 && (b = b.substring(a.length));
    return vd(b);
  }
};
function oc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case wd:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b) {
    return null;
  }
}
k.Da = function() {
  return this.m;
};
k.La = function() {
  return typeof this.j === "string" ? this.j : String(this.j);
};
function Fd(a) {
  var b = "";
  xa(a, function(c, d) {
    b += d;
    b += ":";
    b += c;
    b += "\r\n";
  });
  return b;
}
function Gd(a, b, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = Fd(c), typeof a === "string" ? c != null && encodeURIComponent(String(c)) : R(a, b, c));
}
function Hd(a, b, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b : b;
}
function Id(a) {
  this.za = 0;
  this.l = [];
  this.h = new Mb();
  this.la = this.oa = this.F = this.W = this.g = this.sa = this.D = this.aa = this.o = this.P = this.s = null;
  this.Za = this.V = 0;
  this.Xa = Hd("failFast", false, a);
  this.N = this.v = this.u = this.m = this.j = null;
  this.X = true;
  this.I = this.ta = this.U = -1;
  this.Y = this.A = this.C = 0;
  this.Pa = Hd("baseRetryDelayMs", 5e3, a);
  this.$a = Hd("retryDelaySeedMs", 1e4, a);
  this.Ya = Hd("forwardChannelMaxRetries", 2, a);
  this.ra = Hd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.qa = a && a.xmlHttpFactory || void 0;
  this.Ba = a && a.Yb || false;
  this.K = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.J = "";
  this.i = new gd(a && a.concurrentRequestLimit);
  this.Ca = new ld();
  this.ja = a && a.fastHandshake || false;
  this.Ra = a && a.Wb || false;
  a && a.Aa && this.h.Aa();
  a && a.forceLongPolling && (this.X = false);
  this.$ = !this.ja && this.X && a && a.detectBufferingProxy || false;
  this.ka = void 0;
  this.O = 0;
  this.L = false;
  this.B = null;
  this.Wa = !a || a.Xb !== false;
}
k = Id.prototype;
k.ma = 8;
k.G = 1;
function Ic(a) {
  Jd(a);
  if (a.G == 3) {
    var b = a.V++, c = N(a.F);
    R(c, "SID", a.J);
    R(c, "RID", b);
    R(c, "TYPE", "terminate");
    Kd(a, c);
    b = new M(a, a.h, b, void 0);
    b.K = 2;
    b.v = jc(N(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b.v.toString(), ""));
    !c && l.Image && (new Image().src = b.v, c = true);
    c || (b.g = nc(b.l, null), b.g.ea(b.v));
    b.F = Date.now();
    lc(b);
  }
  Ld(a);
}
k.hb = function(a) {
  try {
    this.h.info("Origin Trials invoked: " + a);
  } catch (b) {
  }
};
function Ac(a) {
  a.g && (wc(a), a.g.cancel(), a.g = null);
}
function Jd(a) {
  Ac(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  zc(a);
  a.i.cancel();
  a.m && (typeof a.m === "number" && l.clearTimeout(a.m), a.m = null);
}
function Md(a, b) {
  a.l.push(new fd(a.Za++, b));
  a.G == 3 && Hc(a);
}
function Hc(a) {
  id(a.i) || a.m || (a.m = true, zb(a.Ha, a), a.C = 0);
}
function Nd(a, b) {
  if (Cc(a.i) >= a.i.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.l = b.D.concat(a.l), true;
  if (a.G == 1 || a.G == 2 || a.C >= (a.Xa ? 0 : a.Ya))
    return false;
  a.m = K(q(a.Ha, a, b), Od(a, a.C));
  a.C++;
  return true;
}
k.Ha = function(a) {
  if (this.m)
    if (this.m = null, this.G == 1) {
      if (!a) {
        this.V = Math.floor(1e5 * Math.random());
        a = this.V++;
        var e = new M(this, this.h, a, void 0);
        var f = this.s;
        this.P && (f ? (f = ya(f), Aa(f, this.P)) : f = this.P);
        this.o === null && (e.H = f);
        if (this.ja)
          a: {
            var b = 0;
            for (var c = 0; c < this.l.length; c++) {
              b: {
                var d = this.l[c];
                if ("__data__" in d.g && (d = d.g.__data__, typeof d === "string")) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (d === void 0)
                break;
              b += d;
              if (4096 < b) {
                b = c;
                break a;
              }
              if (b === 4096 || c === this.l.length - 1) {
                b = c + 1;
                break a;
              }
            }
            b = 1e3;
          }
        else
          b = 1e3;
        b = Pd(this, e, b);
        c = N(this.F);
        R(c, "RID", a);
        R(c, "CVER", 22);
        this.D && R(c, "X-HTTP-Session-Id", this.D);
        Kd(this, c);
        this.o && f && Gd(c, this.o, f);
        Dc(this.i, e);
        this.Ra && R(c, "TYPE", "init");
        this.ja ? (R(c, "$req", b), R(c, "SID", "null"), e.$ = true, ic(e, c, null)) : ic(e, c, b);
        this.G = 2;
      }
    } else
      this.G == 3 && (a ? Qd(this, a) : this.l.length == 0 || id(this.i) || Qd(this));
};
function Qd(a, b) {
  var c;
  b ? c = b.m : c = a.V++;
  var d = N(a.F);
  R(d, "SID", a.J);
  R(d, "RID", c);
  R(d, "AID", a.U);
  Kd(a, d);
  a.o && a.s && Gd(d, a.o, a.s);
  c = new M(a, a.h, c, a.C + 1);
  a.o === null && (c.H = a.s);
  b && (a.l = b.D.concat(a.l));
  b = Pd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ra) + Math.round(0.5 * a.ra * Math.random()));
  Dc(a.i, c);
  ic(c, d, b);
}
function Kd(a, b) {
  a.j && Kc({}, function(c, d) {
    R(b, d, c);
  });
}
function Pd(a, b, c) {
  c = Math.min(a.l.length, c);
  var d = a.j ? q(a.j.Oa, a.j, a) : null;
  a: {
    var e = a.l;
    var f = -1;
    for (; ; ) {
      var h = ["count=" + c];
      f == -1 ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      var n = true;
      for (var u = 0; u < c; u++) {
        var m = e[u].h;
        var r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            md(r, h, "req" + m + "_");
          } catch (G2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.l.splice(0, c);
  b.D = a;
  return d;
}
function Gc(a) {
  a.g || a.u || (a.Y = 1, zb(a.Ga, a), a.A = 0);
}
function Bc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Y++;
  a.u = K(q(a.Ga, a), Od(a, a.A));
  a.A++;
  return true;
}
k.Ga = function() {
  this.u = null;
  Rd(this);
  if (this.$ && !(this.L || this.g == null || 0 >= this.O)) {
    var a = 2 * this.O;
    this.h.info("BP detection timer enabled: " + a);
    this.B = K(q(this.bb, this), a);
  }
};
k.bb = function() {
  this.B && (this.B = null, this.h.info("BP detection timeout reached."), this.h.info("Buffering proxy detected and switch to long-polling!"), this.N = false, this.L = true, J(10), Ac(this), Rd(this));
};
function wc(a) {
  a.B != null && (l.clearTimeout(a.B), a.B = null);
}
function Rd(a) {
  a.g = new M(a, a.h, "rpc", a.Y);
  a.o === null && (a.g.H = a.s);
  a.g.O = 0;
  var b = N(a.oa);
  R(b, "RID", "rpc");
  R(b, "SID", a.J);
  R(b, "CI", a.N ? "0" : "1");
  R(b, "AID", a.U);
  Kd(a, b);
  R(b, "TYPE", "xmlhttp");
  a.o && a.s && Gd(b, a.o, a.s);
  a.K && a.g.setTimeout(a.K);
  var c = a.g;
  a = a.la;
  c.K = 1;
  c.v = jc(N(b));
  c.s = null;
  c.U = true;
  kc(c, a);
}
k.ab = function() {
  this.v != null && (this.v = null, Ac(this), Bc(this), J(19));
};
function zc(a) {
  a.v != null && (l.clearTimeout(a.v), a.v = null);
}
function uc(a, b) {
  var c = null;
  if (a.g == b) {
    zc(a);
    wc(a);
    a.g = null;
    var d = 2;
  } else if (yc(a.i, b))
    c = b.D, Fc(a.i, b), d = 1;
  else
    return;
  a.I = b.N;
  if (a.G != 0) {
    if (b.i)
      if (d == 1) {
        c = b.s ? b.s.length : 0;
        b = Date.now() - b.F;
        var e = a.C;
        d = Sb();
        D(d, new Vb(d, c, b, e));
        Hc(a);
      } else
        Gc(a);
    else if (e = b.o, e == 3 || e == 0 && 0 < a.I || !(d == 1 && Nd(a, b) || d == 2 && Bc(a)))
      switch (c && 0 < c.length && (b = a.i, b.i = b.i.concat(c)), e) {
        case 1:
          Q(a, 5);
          break;
        case 4:
          Q(a, 10);
          break;
        case 3:
          Q(a, 6);
          break;
        default:
          Q(a, 2);
      }
  }
}
function Od(a, b) {
  var c = a.Pa + Math.floor(Math.random() * a.$a);
  a.j || (c *= 2);
  return c * b;
}
function Q(a, b) {
  a.h.info("Error code " + b);
  if (b == 2) {
    var c = null;
    a.j && (c = null);
    var d = q(a.jb, a);
    c || (c = new U("//www.google.com/images/cleardot.gif"), l.location && l.location.protocol == "http" || Oc(c, "https"), jc(c));
    nd(c.toString(), d);
  } else
    J(2);
  a.G = 0;
  a.j && a.j.va(b);
  Ld(a);
  Jd(a);
}
k.jb = function(a) {
  a ? (this.h.info("Successfully pinged google.com"), J(2)) : (this.h.info("Failed to ping google.com"), J(1));
};
function Ld(a) {
  a.G = 0;
  a.I = -1;
  if (a.j) {
    if (jd(a.i).length != 0 || a.l.length != 0)
      a.i.i.length = 0, ra(a.l), a.l.length = 0;
    a.j.ua();
  }
}
function Ec(a, b, c) {
  var d = ad(c);
  if (d.i != "")
    b && Pc(d, b + "." + d.i), Qc(d, d.m);
  else {
    var e = l.location;
    d = bd(e.protocol, b ? b + "." + e.hostname : e.hostname, +e.port, c);
  }
  a.aa && xa(a.aa, function(e2, f) {
    R(d, f, e2);
  });
  b = a.D;
  c = a.sa;
  b && c && R(d, b, c);
  R(d, "VER", a.ma);
  Kd(a, d);
  return d;
}
function nc(a, b, c) {
  if (b && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b = c && a.Ba && !a.qa ? new X(new pd({ ib: true })) : new X(a.qa);
  b.L = a.H;
  return b;
}
function Sd() {
}
k = Sd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Oa = function() {
};
function Td() {
  if (y && !(10 <= Number(Ua)))
    throw Error("Environmental error: no available transport.");
}
Td.prototype.g = function(a, b) {
  return new Y(a, b);
};
function Y(a, b) {
  C.call(this);
  this.g = new Id(b);
  this.l = a;
  this.h = b && b.messageUrlParams || null;
  a = b && b.messageHeaders || null;
  b && b.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b && b.initMessageHeaders || null;
  b && b.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b.messageContentType : a = { "X-WebChannel-Content-Type": b.messageContentType });
  b && b.ya && (a ? a["X-WebChannel-Client-Profile"] = b.ya : a = { "X-WebChannel-Client-Profile": b.ya });
  this.g.P = a;
  (a = b && b.httpHeadersOverwriteParam) && !sa(a) && (this.g.o = a);
  this.A = b && b.supportsCrossDomainXhr || false;
  this.v = b && b.sendRawJson || false;
  (b = b && b.httpSessionIdParam) && !sa(b) && (this.g.D = b, a = this.h, a !== null && b in a && (a = this.h, b in a && delete a[b]));
  this.j = new Z(this);
}
t(Y, C);
Y.prototype.m = function() {
  this.g.j = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b = this.l, c = this.h || void 0;
  a.Wa && (a.h.info("Origin Trials enabled."), zb(q(a.hb, a, b)));
  J(0);
  a.W = b;
  a.aa = c || {};
  a.N = a.X;
  a.F = Ec(a, null, a.W);
  Hc(a);
};
Y.prototype.close = function() {
  Ic(this.g);
};
Y.prototype.u = function(a) {
  if (typeof a === "string") {
    var b = {};
    b.__data__ = a;
    Md(this.g, b);
  } else
    this.v ? (b = {}, b.__data__ = rb(a), Md(this.g, b)) : Md(this.g, a);
};
Y.prototype.M = function() {
  this.g.j = null;
  delete this.j;
  Ic(this.g);
  delete this.g;
  Y.Z.M.call(this);
};
function Ud(a) {
  ac.call(this);
  var b = a.__sm__;
  if (b) {
    a: {
      for (var c in b) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b = b !== null && a in b ? b[a] : void 0;
    this.data = b;
  } else
    this.data = a;
}
t(Ud, ac);
function Vd() {
  bc.call(this);
  this.status = 1;
}
t(Vd, bc);
function Z(a) {
  this.g = a;
}
t(Z, Sd);
Z.prototype.xa = function() {
  D(this.g, "a");
};
Z.prototype.wa = function(a) {
  D(this.g, new Ud(a));
};
Z.prototype.va = function(a) {
  D(this.g, new Vd(a));
};
Z.prototype.ua = function() {
  D(this.g, "b");
};
Td.prototype.createWebChannel = Td.prototype.g;
Y.prototype.send = Y.prototype.u;
Y.prototype.open = Y.prototype.m;
Y.prototype.close = Y.prototype.close;
Wb.NO_ERROR = 0;
Wb.TIMEOUT = 8;
Wb.HTTP_ERROR = 6;
Xb.COMPLETE = "complete";
$b.EventType = L;
L.OPEN = "a";
L.CLOSE = "b";
L.ERROR = "c";
L.MESSAGE = "d";
C.prototype.listen = C.prototype.N;
X.prototype.listenOnce = X.prototype.O;
X.prototype.getLastError = X.prototype.La;
X.prototype.getLastErrorCode = X.prototype.Da;
X.prototype.getStatus = X.prototype.ba;
X.prototype.getResponseJson = X.prototype.Qa;
X.prototype.getResponseText = X.prototype.ga;
X.prototype.send = X.prototype.ea;
var createWebChannelTransport = function() {
  return new Td();
};
var getStatEventTarget = function() {
  return Sb();
};
var ErrorCode = Wb;
var EventType = Xb;
var Event = H;
var Stat = { rb: 0, ub: 1, vb: 2, Ob: 3, Tb: 4, Qb: 5, Rb: 6, Pb: 7, Nb: 8, Sb: 9, PROXY: 10, NOPROXY: 11, Lb: 12, Hb: 13, Ib: 14, Gb: 15, Jb: 16, Kb: 17, nb: 18, mb: 19, ob: 20 };
var FetchXmlHttpFactory = pd;
var WebChannel = $b;
var XhrIo = X;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var S2 = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return this.uid != null;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
S2.UNAUTHENTICATED = new S2(null), S2.GOOGLE_CREDENTIALS = new S2("google-credentials-uid"), S2.FIRST_PARTY = new S2("first-party-uid"), S2.MOCK_USER = new S2("mock-user");
var D2 = "9.0.1";
var C2 = new Logger("@firebase/firestore");
function N2() {
  return C2.logLevel;
}
function x2(t2) {
  C2.setLogLevel(t2);
}
function k2(t2, ...e) {
  if (C2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(F2);
    C2.debug(`Firestore (${D2}): ${t2}`, ...n);
  }
}
function $(t2, ...e) {
  if (C2.logLevel <= LogLevel.ERROR) {
    const n = e.map(F2);
    C2.error(`Firestore (${D2}): ${t2}`, ...n);
  }
}
function O2(t2, ...e) {
  if (C2.logLevel <= LogLevel.WARN) {
    const n = e.map(F2);
    C2.warn(`Firestore (${D2}): ${t2}`, ...n);
  }
}
function F2(t2) {
  if (typeof t2 == "string")
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function M2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${D2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw $(e), new Error(e);
}
function L2(t2, e) {
  t2 || M2();
}
function B2(t2, e) {
  t2 || M2();
}
function U2(t2, e) {
  return t2;
}
var q2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var K2 = class extends Error {
  constructor(t2, e) {
    super(e), this.code = t2, this.message = e, this.name = "FirebaseError", this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var j = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var Q2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.authHeaders = {}, this.authHeaders.Authorization = `Bearer ${t2}`;
  }
};
var W2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(S2.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var G = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var z2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = S2.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new j();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new j(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = (e2) => {
      t2.enqueueRetryable(async () => {
        k2("FirebaseCredentialsProvider", "Auth detected"), this.auth = e2, this.auth.addAuthTokenListener(this.o), await i.promise, await s(this.currentUser);
      });
    };
    this.t.onInit((t3) => r(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? r(t3) : (k2("FirebaseCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new j());
      }
    }, 0), t2.enqueueRetryable(async () => {
      this.i === 0 && (await i.promise, await s(this.currentUser));
    });
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (k2("FirebaseCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? (L2(typeof e2.accessToken == "string"), new Q2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return L2(t2 === null || typeof t2 == "string"), new S2(t2);
  }
};
var H2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n, this.type = "FirstParty", this.user = S2.FIRST_PARTY;
  }
  get authHeaders() {
    const t2 = {
      "X-Goog-AuthUser": this.l
    }, e = this.h.auth.getAuthHeaderValueForFirstParty([]);
    return e && (t2.Authorization = e), this.m && (t2["X-Goog-Iam-Authorization-Token"] = this.m), t2;
  }
};
var J2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new H2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(S2.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var Y2 = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.g(t3), this.p = (t3) => e.writeSequenceNumber(t3));
  }
  g(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.p && this.p(t2), t2;
  }
};
function X2(t2) {
  const e = typeof self != "undefined" && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && typeof e.getRandomValues == "function")
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
Y2.T = -1;
var Z2 = class {
  static I() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = X2(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function tt(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function et(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function nt(t2) {
  return t2 + "\0";
}
var st = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new K2(q2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new K2(q2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new K2(q2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new K2(q2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return st.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return st.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new st(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? tt(this.nanoseconds, t2.nanoseconds) : tt(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var it = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new it(t2);
  }
  static min() {
    return new it(new st(0, 0));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
function rt(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function ot(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function at(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var ct = class {
  constructor(t2, e, n) {
    e === void 0 ? e = 0 : e > t2.length && M2(), n === void 0 ? n = t2.length - e : n > t2.length - e && M2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return ct.comparator(this, t2) === 0;
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof ct ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = t2 === void 0 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return this.length === 0;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var ut = class extends ct {
  construct(t2, e, n) {
    return new ut(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new K2(q2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new ut(e);
  }
  static emptyPath() {
    return new ut([]);
  }
};
var ht = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var lt = class extends ct {
  construct(t2, e, n) {
    return new lt(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return ht.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), lt.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return this.length === 1 && this.get(0) === "__name__";
  }
  static keyField() {
    return new lt(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (n.length === 0)
        throw new K2(q2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if (e2 === "\\") {
        if (s + 1 === t2.length)
          throw new K2(q2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if (e3 !== "\\" && e3 !== "." && e3 !== "`")
          throw new K2(q2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        e2 === "`" ? (r = !r, s++) : e2 !== "." || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new K2(q2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new lt(e);
  }
  static emptyPath() {
    return new lt([]);
  }
};
var ft = class {
  constructor(t2) {
    this.fields = t2, t2.sort(lt.comparator);
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return et(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
function dt() {
  return typeof atob != "undefined";
}
var wt = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = atob(t2);
    return new wt(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new wt(e);
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return tt(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
wt.EMPTY_BYTE_STRING = new wt("");
var _t = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function mt(t2) {
  if (L2(!!t2), typeof t2 == "string") {
    let e = 0;
    const n = _t.exec(t2);
    if (L2(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: gt(t2.seconds),
    nanos: gt(t2.nanos)
  };
}
function gt(t2) {
  return typeof t2 == "number" ? t2 : typeof t2 == "string" ? Number(t2) : 0;
}
function yt(t2) {
  return typeof t2 == "string" ? wt.fromBase64String(t2) : wt.fromUint8Array(t2);
}
function pt(t2) {
  var e, n;
  return ((n = (((e = t2 == null ? void 0 : t2.mapValue) === null || e === void 0 ? void 0 : e.fields) || {}).__type__) === null || n === void 0 ? void 0 : n.stringValue) === "server_timestamp";
}
function Et(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return pt(e) ? Et(e) : e;
}
function Tt(t2) {
  const e = mt(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new st(e.seconds, e.nanos);
}
function It(t2) {
  return t2 == null;
}
function At(t2) {
  return t2 === 0 && 1 / t2 == -1 / 0;
}
function Rt(t2) {
  return typeof t2 == "number" && Number.isInteger(t2) && !At(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
var Pt = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new Pt(ut.fromString(t2));
  }
  static fromName(t2) {
    return new Pt(ut.fromString(t2).popFirst(5));
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  isEqual(t2) {
    return t2 !== null && ut.comparator(this.path, t2.path) === 0;
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return ut.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new Pt(new ut(t2.slice()));
  }
};
function bt(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? pt(t2) ? 4 : 10 : M2();
}
function vt(t2, e) {
  const n = bt(t2);
  if (n !== bt(e))
    return false;
  switch (n) {
    case 0:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Tt(t2).isEqual(Tt(e));
    case 3:
      return function(t3, e2) {
        if (typeof t3.timestampValue == "string" && typeof e2.timestampValue == "string" && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = mt(t3.timestampValue), s = mt(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return yt(t3.bytesValue).isEqual(yt(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return gt(t3.geoPointValue.latitude) === gt(e2.geoPointValue.latitude) && gt(t3.geoPointValue.longitude) === gt(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return gt(t3.integerValue) === gt(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = gt(t3.doubleValue), s = gt(e2.doubleValue);
          return n2 === s ? At(n2) === At(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return et(t2.arrayValue.values || [], e.arrayValue.values || [], vt);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (rt(n2) !== rt(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (s[t4] === void 0 || !vt(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return M2();
  }
}
function Vt(t2, e) {
  return (t2.values || []).find((t3) => vt(t3, e)) !== void 0;
}
function St(t2, e) {
  const n = bt(t2), s = bt(e);
  if (n !== s)
    return tt(n, s);
  switch (n) {
    case 0:
      return 0;
    case 1:
      return tt(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = gt(t3.integerValue || t3.doubleValue), s2 = gt(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Dt(t2.timestampValue, e.timestampValue);
    case 4:
      return Dt(Tt(t2), Tt(e));
    case 5:
      return tt(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = yt(t3), s2 = yt(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = tt(n2[t4], s2[t4]);
          if (e3 !== 0)
            return e3;
        }
        return tt(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = tt(gt(t3.latitude), gt(e2.latitude));
        if (n2 !== 0)
          return n2;
        return tt(gt(t3.longitude), gt(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = St(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return tt(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = tt(s2[t4], r[t4]);
          if (e3 !== 0)
            return e3;
          const o = St(n2[s2[t4]], i[r[t4]]);
          if (o !== 0)
            return o;
        }
        return tt(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw M2();
  }
}
function Dt(t2, e) {
  if (typeof t2 == "string" && typeof e == "string" && t2.length === e.length)
    return tt(t2, e);
  const n = mt(t2), s = mt(e), i = tt(n.seconds, s.seconds);
  return i !== 0 ? i : tt(n.nanos, s.nanos);
}
function Ct(t2) {
  return Nt(t2);
}
function Nt(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = mt(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? yt(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, Pt.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Nt(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Nt(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : M2();
  var e, n;
}
function xt(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function kt(t2) {
  return !!t2 && "integerValue" in t2;
}
function $t(t2) {
  return !!t2 && "arrayValue" in t2;
}
function Ot(t2) {
  return !!t2 && "nullValue" in t2;
}
function Ft(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Mt(t2) {
  return !!t2 && "mapValue" in t2;
}
function Lt(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && typeof t2.timestampValue == "object")
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return ot(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Lt(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Lt(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
var Bt = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new Bt({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Mt(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Lt(e);
  }
  setAll(t2) {
    let e = lt.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Lt(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Mt(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return vt(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Mt(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    ot(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new Bt(Lt(this.value));
  }
};
function Ut(t2) {
  const e = [];
  return ot(t2.fields, (t3, n) => {
    const s = new lt([t3]);
    if (Mt(n)) {
      const t4 = Ut(n.mapValue).fields;
      if (t4.length === 0)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new ft(e);
}
var qt = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.documentType = e, this.version = n, this.data = s, this.documentState = i;
  }
  static newInvalidDocument(t2) {
    return new qt(t2, 0, it.min(), Bt.empty(), 0);
  }
  static newFoundDocument(t2, e, n) {
    return new qt(t2, 1, e, n, 0);
  }
  static newNoDocument(t2, e) {
    return new qt(t2, 2, e, Bt.empty(), 0);
  }
  static newUnknownDocument(t2, e) {
    return new qt(t2, 3, e, Bt.empty(), 2);
  }
  convertToFoundDocument(t2, e) {
    return this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = Bt.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = Bt.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this;
  }
  get hasLocalMutations() {
    return this.documentState === 1;
  }
  get hasCommittedMutations() {
    return this.documentState === 2;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return this.documentType !== 0;
  }
  isFoundDocument() {
    return this.documentType === 1;
  }
  isNoDocument() {
    return this.documentType === 2;
  }
  isUnknownDocument() {
    return this.documentType === 3;
  }
  isEqual(t2) {
    return t2 instanceof qt && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  clone() {
    return new qt(this.key, this.documentType, this.version, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var Kt = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.A = null;
  }
};
function jt(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Kt(t2, e, n, s, i, r, o);
}
function Qt(t2) {
  const e = U2(t2);
  if (e.A === null) {
    let t3 = e.path.canonicalString();
    e.collectionGroup !== null && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => Jt(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), It(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += oe(e.startAt)), e.endAt && (t3 += "|ub:", t3 += oe(e.endAt)), e.A = t3;
  }
  return e.A;
}
function Wt(t2) {
  let e = t2.path.canonicalString();
  return t2.collectionGroup !== null && (e += " collectionGroup=" + t2.collectionGroup), t2.filters.length > 0 && (e += `, filters: [${t2.filters.map((t3) => {
    return `${(e2 = t3).field.canonicalString()} ${e2.op} ${Ct(e2.value)}`;
    var e2;
  }).join(", ")}]`), It(t2.limit) || (e += ", limit: " + t2.limit), t2.orderBy.length > 0 && (e += `, orderBy: [${t2.orderBy.map((t3) => function(t4) {
    return `${t4.field.canonicalString()} (${t4.dir})`;
  }(t3)).join(", ")}]`), t2.startAt && (e += ", startAt: " + oe(t2.startAt)), t2.endAt && (e += ", endAt: " + oe(t2.endAt)), `Target(${e})`;
}
function Gt(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n2 = 0; n2 < t2.orderBy.length; n2++)
    if (!ce(t2.orderBy[n2], e.orderBy[n2]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let i = 0; i < t2.filters.length; i++)
    if (n = t2.filters[i], s = e.filters[i], n.op !== s.op || !n.field.isEqual(s.field) || !vt(n.value, s.value))
      return false;
  var n, s;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!he(t2.startAt, e.startAt) && he(t2.endAt, e.endAt)));
}
function zt(t2) {
  return Pt.isDocumentKey(t2.path) && t2.collectionGroup === null && t2.filters.length === 0;
}
var Ht = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? e === "in" || e === "not-in" ? this.R(t2, e, n) : new Yt(t2, e, n) : e === "array-contains" ? new ee(t2, n) : e === "in" ? new ne(t2, n) : e === "not-in" ? new se(t2, n) : e === "array-contains-any" ? new ie(t2, n) : new Ht(t2, e, n);
  }
  static R(t2, e, n) {
    return e === "in" ? new Xt(t2, n) : new Zt(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return this.op === "!=" ? e !== null && this.P(St(e, this.value)) : e !== null && bt(this.value) === bt(e) && this.P(St(e, this.value));
  }
  P(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return t2 === 0;
      case "!=":
        return t2 !== 0;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return M2();
    }
  }
  v() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
};
function Jt(t2) {
  return t2.field.canonicalString() + t2.op.toString() + Ct(t2.value);
}
var Yt = class extends Ht {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = Pt.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = Pt.comparator(t2.key, this.key);
    return this.P(e);
  }
};
var Xt = class extends Ht {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = te("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var Zt = class extends Ht {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = te("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function te(t2, e) {
  var n;
  return (((n = e.arrayValue) === null || n === void 0 ? void 0 : n.values) || []).map((t3) => Pt.fromName(t3.referenceValue));
}
var ee = class extends Ht {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return $t(e) && Vt(e.arrayValue, this.value);
  }
};
var ne = class extends Ht {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return e !== null && Vt(this.value.arrayValue, e);
  }
};
var se = class extends Ht {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (Vt(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return e !== null && !Vt(this.value.arrayValue, e);
  }
};
var ie = class extends Ht {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!$t(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => Vt(this.value.arrayValue, t3));
  }
};
var re = class {
  constructor(t2, e) {
    this.position = t2, this.before = e;
  }
};
function oe(t2) {
  return `${t2.before ? "b" : "a"}:${t2.position.map((t3) => Ct(t3)).join(",")}`;
}
var ae = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function ce(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
function ue(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = Pt.comparator(Pt.fromName(o.referenceValue), n.key);
    else {
      s = St(o, n.data.field(r.field));
    }
    if (r.dir === "desc" && (s *= -1), s !== 0)
      break;
  }
  return t2.before ? s <= 0 : s < 0;
}
function he(t2, e) {
  if (t2 === null)
    return e === null;
  if (e === null)
    return false;
  if (t2.before !== e.before || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!vt(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var le = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, a = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = a, this.V = null, this.S = null, this.startAt, this.endAt;
  }
};
function fe(t2, e, n, s, i, r, o, a) {
  return new le(t2, e, n, s, i, r, o, a);
}
function de(t2) {
  return new le(t2);
}
function we(t2) {
  return !It(t2.limit) && t2.limitType === "F";
}
function _e(t2) {
  return !It(t2.limit) && t2.limitType === "L";
}
function me(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function ge(t2) {
  for (const e of t2.filters)
    if (e.v())
      return e.field;
  return null;
}
function ye(t2) {
  return t2.collectionGroup !== null;
}
function pe(t2) {
  const e = U2(t2);
  if (e.V === null) {
    e.V = [];
    const t3 = ge(e), n = me(e);
    if (t3 !== null && n === null)
      t3.isKeyField() || e.V.push(new ae(t3)), e.V.push(new ae(lt.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.V.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.V.push(new ae(lt.keyField(), t5));
      }
    }
  }
  return e.V;
}
function Ee(t2) {
  const e = U2(t2);
  if (!e.S)
    if (e.limitType === "F")
      e.S = jt(e.path, e.collectionGroup, pe(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of pe(e)) {
        const e2 = n2.dir === "desc" ? "asc" : "desc";
        t3.push(new ae(n2.field, e2));
      }
      const n = e.endAt ? new re(e.endAt.position, !e.endAt.before) : null, s = e.startAt ? new re(e.startAt.position, !e.startAt.before) : null;
      e.S = jt(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.S;
}
function Te(t2, e, n) {
  return new le(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Ie(t2, e) {
  return Gt(Ee(t2), Ee(e)) && t2.limitType === e.limitType;
}
function Ae(t2) {
  return `${Qt(Ee(t2))}|lt:${t2.limitType}`;
}
function Re(t2) {
  return `Query(target=${Wt(Ee(t2))}; limitType=${t2.limitType})`;
}
function Pe(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return t3.collectionGroup !== null ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : Pt.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of t3.explicitOrderBy)
      if (!n.field.isKeyField() && e2.data.field(n.field) === null)
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !ue(t3.startAt, pe(t3), e2))
      return false;
    if (t3.endAt && ue(t3.endAt, pe(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function be(t2) {
  return (e, n) => {
    let s = false;
    for (const i of pe(t2)) {
      const t3 = ve(i, e, n);
      if (t3 !== 0)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function ve(t2, e, n) {
  const s = t2.field.isKeyField() ? Pt.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return s2 !== null && i !== null ? St(s2, i) : M2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return M2();
  }
}
function Ve(t2, e) {
  if (t2.D) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: At(e) ? "-0" : e
  };
}
function Se(t2) {
  return {
    integerValue: "" + t2
  };
}
function De(t2, e) {
  return Rt(e) ? Se(e) : Ve(t2, e);
}
var Ce = class {
  constructor() {
    this._ = void 0;
  }
};
function Ne(t2, e, n) {
  return t2 instanceof $e ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof Oe ? Fe(t2, e) : t2 instanceof Me ? Le(t2, e) : function(t3, e2) {
    const n2 = ke(t3, e2), s = Ue(n2) + Ue(t3.C);
    return kt(n2) && kt(t3.C) ? Se(s) : Ve(t3.N, s);
  }(t2, e);
}
function xe(t2, e, n) {
  return t2 instanceof Oe ? Fe(t2, e) : t2 instanceof Me ? Le(t2, e) : n;
}
function ke(t2, e) {
  return t2 instanceof Be ? kt(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var $e = class extends Ce {
};
var Oe = class extends Ce {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Fe(t2, e) {
  const n = qe(e);
  for (const e2 of t2.elements)
    n.some((t3) => vt(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Me = class extends Ce {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Le(t2, e) {
  let n = qe(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !vt(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Be = class extends Ce {
  constructor(t2, e) {
    super(), this.N = t2, this.C = e;
  }
};
function Ue(t2) {
  return gt(t2.integerValue || t2.doubleValue);
}
function qe(t2) {
  return $t(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var Ke = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function je(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof Oe && e2 instanceof Oe || t3 instanceof Me && e2 instanceof Me ? et(t3.elements, e2.elements, vt) : t3 instanceof Be && e2 instanceof Be ? vt(t3.C, e2.C) : t3 instanceof $e && e2 instanceof $e;
  }(t2.transform, e.transform);
}
var Qe = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var We = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new We();
  }
  static exists(t2) {
    return new We(void 0, t2);
  }
  static updateTime(t2) {
    return new We(t2);
  }
  get isNone() {
    return this.updateTime === void 0 && this.exists === void 0;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function Ge(t2, e) {
  return t2.updateTime !== void 0 ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : t2.exists === void 0 || t2.exists === e.isFoundDocument();
}
var ze = class {
};
function He(t2, e, n) {
  t2 instanceof tn ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = sn(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof en ? function(t3, e2, n2) {
    if (!Ge(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = sn(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(nn(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Je(t2, e, n) {
  t2 instanceof tn ? function(t3, e2, n2) {
    if (!Ge(t3.precondition, e2))
      return;
    const s = t3.value.clone(), i = rn(t3.fieldTransforms, n2, e2);
    s.setAll(i), e2.convertToFoundDocument(Ze(e2), s).setHasLocalMutations();
  }(t2, e, n) : t2 instanceof en ? function(t3, e2, n2) {
    if (!Ge(t3.precondition, e2))
      return;
    const s = rn(t3.fieldTransforms, n2, e2), i = e2.data;
    i.setAll(nn(t3)), i.setAll(s), e2.convertToFoundDocument(Ze(e2), i).setHasLocalMutations();
  }(t2, e, n) : function(t3, e2) {
    Ge(t3.precondition, e2) && e2.convertToNoDocument(it.min());
  }(t2, e);
}
function Ye(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = ke(s.transform, t3 || null);
    i != null && (n == null && (n = Bt.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Xe(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return t3 === void 0 && e2 === void 0 || !(!t3 || !e2) && et(t3, e2, (t4, e3) => je(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (t2.type === 0 ? t2.value.isEqual(e.value) : t2.type !== 1 || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
function Ze(t2) {
  return t2.isFoundDocument() ? t2.version : it.min();
}
var tn = class extends ze {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
};
var en = class extends ze {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
};
function nn(t2) {
  const e = new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function sn(t2, e, n) {
  const s = new Map();
  L2(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, a = e.data.field(r.field);
    s.set(r.field, xe(o, a, n[i]));
  }
  return s;
}
function rn(t2, e, n) {
  const s = new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Ne(t3, r, e));
  }
  return s;
}
var on = class extends ze {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
};
var an = class extends ze {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
};
var cn = class {
  constructor(t2) {
    this.count = t2;
  }
};
var un;
var hn;
function ln(t2) {
  switch (t2) {
    case q2.OK:
      return M2();
    case q2.CANCELLED:
    case q2.UNKNOWN:
    case q2.DEADLINE_EXCEEDED:
    case q2.RESOURCE_EXHAUSTED:
    case q2.INTERNAL:
    case q2.UNAVAILABLE:
    case q2.UNAUTHENTICATED:
      return false;
    case q2.INVALID_ARGUMENT:
    case q2.NOT_FOUND:
    case q2.ALREADY_EXISTS:
    case q2.PERMISSION_DENIED:
    case q2.FAILED_PRECONDITION:
    case q2.ABORTED:
    case q2.OUT_OF_RANGE:
    case q2.UNIMPLEMENTED:
    case q2.DATA_LOSS:
      return true;
    default:
      return M2();
  }
}
function fn(t2) {
  if (t2 === void 0)
    return $("GRPC error has no .code"), q2.UNKNOWN;
  switch (t2) {
    case un.OK:
      return q2.OK;
    case un.CANCELLED:
      return q2.CANCELLED;
    case un.UNKNOWN:
      return q2.UNKNOWN;
    case un.DEADLINE_EXCEEDED:
      return q2.DEADLINE_EXCEEDED;
    case un.RESOURCE_EXHAUSTED:
      return q2.RESOURCE_EXHAUSTED;
    case un.INTERNAL:
      return q2.INTERNAL;
    case un.UNAVAILABLE:
      return q2.UNAVAILABLE;
    case un.UNAUTHENTICATED:
      return q2.UNAUTHENTICATED;
    case un.INVALID_ARGUMENT:
      return q2.INVALID_ARGUMENT;
    case un.NOT_FOUND:
      return q2.NOT_FOUND;
    case un.ALREADY_EXISTS:
      return q2.ALREADY_EXISTS;
    case un.PERMISSION_DENIED:
      return q2.PERMISSION_DENIED;
    case un.FAILED_PRECONDITION:
      return q2.FAILED_PRECONDITION;
    case un.ABORTED:
      return q2.ABORTED;
    case un.OUT_OF_RANGE:
      return q2.OUT_OF_RANGE;
    case un.UNIMPLEMENTED:
      return q2.UNIMPLEMENTED;
    case un.DATA_LOSS:
      return q2.DATA_LOSS;
    default:
      return M2();
  }
}
(hn = un || (un = {}))[hn.OK = 0] = "OK", hn[hn.CANCELLED = 1] = "CANCELLED", hn[hn.UNKNOWN = 2] = "UNKNOWN", hn[hn.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", hn[hn.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", hn[hn.NOT_FOUND = 5] = "NOT_FOUND", hn[hn.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", hn[hn.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", hn[hn.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", hn[hn.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", hn[hn.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", hn[hn.ABORTED = 10] = "ABORTED", hn[hn.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", hn[hn.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", hn[hn.INTERNAL = 13] = "INTERNAL", hn[hn.UNAVAILABLE = 14] = "UNAVAILABLE", hn[hn.DATA_LOSS = 15] = "DATA_LOSS";
var dn = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || _n.EMPTY;
  }
  insert(t2, e) {
    return new dn(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, _n.BLACK, null, null));
  }
  remove(t2) {
    return new dn(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, _n.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (n === 0)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (s === 0)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new wn(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new wn(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new wn(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new wn(this.root, t2, this.comparator, true);
  }
};
var wn = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (i === 0) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (this.nodeStack.length === 0)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var _n = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = n != null ? n : _n.RED, this.left = s != null ? s : _n.EMPTY, this.right = i != null ? i : _n.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new _n(t2 != null ? t2 : this.key, e != null ? e : this.value, n != null ? n : this.color, s != null ? s : this.left, i != null ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : i === 0 ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return _n.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), e(t2, s.key) === 0) {
        if (s.right.isEmpty())
          return _n.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, _n.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, _n.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw M2();
    if (this.right.isRed())
      throw M2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw M2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
_n.EMPTY = null, _n.RED = true, _n.BLACK = false;
_n.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw M2();
  }
  get value() {
    throw M2();
  }
  get color() {
    throw M2();
  }
  get left() {
    throw M2();
  }
  get right() {
    throw M2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new _n(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var mn = class {
  constructor(t2) {
    this.comparator = t2, this.data = new dn(this.comparator);
  }
  has(t2) {
    return this.data.get(t2) !== null;
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = e !== void 0 ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new gn(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new gn(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof mn))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (this.comparator(t3, s) !== 0)
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new mn(this.comparator);
    return e.data = t2, e;
  }
};
var gn = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
var yn = new dn(Pt.comparator);
function pn() {
  return yn;
}
var En = new dn(Pt.comparator);
function Tn() {
  return En;
}
var In = new dn(Pt.comparator);
function An() {
  return In;
}
var Rn = new mn(Pt.comparator);
function Pn(...t2) {
  let e = Rn;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var bn = new mn(tt);
function vn() {
  return bn;
}
var Vn = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e) {
    const n = new Map();
    return n.set(t2, Sn.createSynthesizedTargetChangeForCurrentChange(t2, e)), new Vn(it.min(), n, vn(), pn(), Pn());
  }
};
var Sn = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e) {
    return new Sn(wt.EMPTY_BYTE_STRING, e, Pn(), Pn(), Pn());
  }
};
var Dn = class {
  constructor(t2, e, n, s) {
    this.k = t2, this.removedTargetIds = e, this.key = n, this.$ = s;
  }
};
var Cn = class {
  constructor(t2, e) {
    this.targetId = t2, this.O = e;
  }
};
var Nn = class {
  constructor(t2, e, n = wt.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var xn = class {
  constructor() {
    this.F = 0, this.M = On(), this.L = wt.EMPTY_BYTE_STRING, this.B = false, this.U = true;
  }
  get current() {
    return this.B;
  }
  get resumeToken() {
    return this.L;
  }
  get q() {
    return this.F !== 0;
  }
  get K() {
    return this.U;
  }
  j(t2) {
    t2.approximateByteSize() > 0 && (this.U = true, this.L = t2);
  }
  W() {
    let t2 = Pn(), e = Pn(), n = Pn();
    return this.M.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          M2();
      }
    }), new Sn(this.L, this.B, t2, e, n);
  }
  G() {
    this.U = false, this.M = On();
  }
  H(t2, e) {
    this.U = true, this.M = this.M.insert(t2, e);
  }
  J(t2) {
    this.U = true, this.M = this.M.remove(t2);
  }
  Y() {
    this.F += 1;
  }
  X() {
    this.F -= 1;
  }
  Z() {
    this.U = true, this.B = true;
  }
};
var kn = class {
  constructor(t2) {
    this.tt = t2, this.et = new Map(), this.nt = pn(), this.st = $n(), this.it = new mn(tt);
  }
  rt(t2) {
    for (const e of t2.k)
      t2.$ && t2.$.isFoundDocument() ? this.ot(e, t2.$) : this.at(e, t2.key, t2.$);
    for (const e of t2.removedTargetIds)
      this.at(e, t2.key, t2.$);
  }
  ct(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.ut(e);
      switch (t2.state) {
        case 0:
          this.ht(e) && n.j(t2.resumeToken);
          break;
        case 1:
          n.X(), n.q || n.G(), n.j(t2.resumeToken);
          break;
        case 2:
          n.X(), n.q || this.removeTarget(e);
          break;
        case 3:
          this.ht(e) && (n.Z(), n.j(t2.resumeToken));
          break;
        case 4:
          this.ht(e) && (this.lt(e), n.j(t2.resumeToken));
          break;
        default:
          M2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.et.forEach((t3, n) => {
      this.ht(n) && e(n);
    });
  }
  ft(t2) {
    const e = t2.targetId, n = t2.O.count, s = this.dt(e);
    if (s) {
      const t3 = s.target;
      if (zt(t3))
        if (n === 0) {
          const n2 = new Pt(t3.path);
          this.at(e, n2, qt.newNoDocument(n2, it.min()));
        } else
          L2(n === 1);
      else {
        this.wt(e) !== n && (this.lt(e), this.it = this.it.add(e));
      }
    }
  }
  _t(t2) {
    const e = new Map();
    this.et.forEach((n2, s2) => {
      const i = this.dt(s2);
      if (i) {
        if (n2.current && zt(i.target)) {
          const e2 = new Pt(i.target.path);
          this.nt.get(e2) !== null || this.gt(s2, e2) || this.at(s2, e2, qt.newNoDocument(e2, t2));
        }
        n2.K && (e.set(s2, n2.W()), n2.G());
      }
    });
    let n = Pn();
    this.st.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.dt(t4);
        return !e3 || e3.purpose === 2 || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    });
    const s = new Vn(t2, e, this.it, this.nt, n);
    return this.nt = pn(), this.st = $n(), this.it = new mn(tt), s;
  }
  ot(t2, e) {
    if (!this.ht(t2))
      return;
    const n = this.gt(t2, e.key) ? 2 : 0;
    this.ut(t2).H(e.key, n), this.nt = this.nt.insert(e.key, e), this.st = this.st.insert(e.key, this.yt(e.key).add(t2));
  }
  at(t2, e, n) {
    if (!this.ht(t2))
      return;
    const s = this.ut(t2);
    this.gt(t2, e) ? s.H(e, 1) : s.J(e), this.st = this.st.insert(e, this.yt(e).delete(t2)), n && (this.nt = this.nt.insert(e, n));
  }
  removeTarget(t2) {
    this.et.delete(t2);
  }
  wt(t2) {
    const e = this.ut(t2).W();
    return this.tt.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Y(t2) {
    this.ut(t2).Y();
  }
  ut(t2) {
    let e = this.et.get(t2);
    return e || (e = new xn(), this.et.set(t2, e)), e;
  }
  yt(t2) {
    let e = this.st.get(t2);
    return e || (e = new mn(tt), this.st = this.st.insert(t2, e)), e;
  }
  ht(t2) {
    const e = this.dt(t2) !== null;
    return e || k2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  dt(t2) {
    const e = this.et.get(t2);
    return e && e.q ? null : this.tt.Et(t2);
  }
  lt(t2) {
    this.et.set(t2, new xn());
    this.tt.getRemoteKeysForTarget(t2).forEach((e) => {
      this.at(t2, e, null);
    });
  }
  gt(t2, e) {
    return this.tt.getRemoteKeysForTarget(t2).has(e);
  }
};
function $n() {
  return new dn(Pt.comparator);
}
function On() {
  return new dn(Pt.comparator);
}
var Fn = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var Mn = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Ln = class {
  constructor(t2, e) {
    this.databaseId = t2, this.D = e;
  }
};
function Bn(t2, e) {
  if (t2.D) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Un(t2, e) {
  return t2.D ? e.toBase64() : e.toUint8Array();
}
function qn(t2, e) {
  return Bn(t2, e.toTimestamp());
}
function Kn(t2) {
  return L2(!!t2), it.fromTimestamp(function(t3) {
    const e = mt(t3);
    return new st(e.seconds, e.nanos);
  }(t2));
}
function jn(t2, e) {
  return function(t3) {
    return new ut(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Qn(t2) {
  const e = ut.fromString(t2);
  return L2(ps(e)), e;
}
function Wn(t2, e) {
  return jn(t2.databaseId, e.path);
}
function Gn(t2, e) {
  const n = Qn(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new K2(q2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new K2(q2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new Pt(Yn(n));
}
function zn(t2, e) {
  return jn(t2.databaseId, e);
}
function Hn(t2) {
  const e = Qn(t2);
  return e.length === 4 ? ut.emptyPath() : Yn(e);
}
function Jn(t2) {
  return new ut(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Yn(t2) {
  return L2(t2.length > 4 && t2.get(4) === "documents"), t2.popFirst(5);
}
function Xn(t2, e, n) {
  return {
    name: Wn(t2, e),
    fields: n.value.mapValue.fields
  };
}
function Zn(t2, e, n) {
  const s = Gn(t2, e.name), i = Kn(e.updateTime), r = new Bt({
    mapValue: {
      fields: e.fields
    }
  }), o = qt.newFoundDocument(s, i, r);
  return n && o.setHasCommittedMutations(), n ? o.setHasCommittedMutations() : o;
}
function ts(t2, e) {
  return "found" in e ? function(t3, e2) {
    L2(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Gn(t3, e2.found.name), s = Kn(e2.found.updateTime), i = new Bt({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return qt.newFoundDocument(n, s, i);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    L2(!!e2.missing), L2(!!e2.readTime);
    const n = Gn(t3, e2.missing), s = Kn(e2.readTime);
    return qt.newNoDocument(n, s);
  }(t2, e) : M2();
}
function es(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return t3 === "NO_CHANGE" ? 0 : t3 === "ADD" ? 1 : t3 === "REMOVE" ? 2 : t3 === "CURRENT" ? 3 : t3 === "RESET" ? 4 : M2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.D ? (L2(e2 === void 0 || typeof e2 == "string"), wt.fromBase64String(e2 || "")) : (L2(e2 === void 0 || e2 instanceof Uint8Array), wt.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, a = o && function(t3) {
      const e2 = t3.code === void 0 ? q2.UNKNOWN : fn(t3.code);
      return new K2(e2, t3.message || "");
    }(o);
    n = new Nn(s, i, r, a || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Gn(t2, s.document.name), r = Kn(s.document.updateTime), o = new Bt({
      mapValue: {
        fields: s.document.fields
      }
    }), a = qt.newFoundDocument(i, r, o), c = s.targetIds || [], u = s.removedTargetIds || [];
    n = new Dn(c, u, a.key, a);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Gn(t2, s.document), r = s.readTime ? Kn(s.readTime) : it.min(), o = qt.newNoDocument(i, r), a = s.removedTargetIds || [];
    n = new Dn([], a, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Gn(t2, s.document), r = s.removedTargetIds || [];
    n = new Dn([], r, i, null);
  } else {
    if (!("filter" in e))
      return M2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new cn(s), r = t3.targetId;
      n = new Cn(r, i);
    }
  }
  return n;
}
function ns(t2, e) {
  let n;
  if (e instanceof tn)
    n = {
      update: Xn(t2, e.key, e.value)
    };
  else if (e instanceof on)
    n = {
      delete: Wn(t2, e.key)
    };
  else if (e instanceof en)
    n = {
      update: Xn(t2, e.key, e.data),
      updateMask: ys(e.fieldMask)
    };
  else {
    if (!(e instanceof an))
      return M2();
    n = {
      verify: Wn(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof $e)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof Oe)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Me)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Be)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2.C
      };
    throw M2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return e2.updateTime !== void 0 ? {
      updateTime: qn(t3, e2.updateTime)
    } : e2.exists !== void 0 ? {
      exists: e2.exists
    } : M2();
  }(t2, e.precondition)), n;
}
function ss(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return t3.updateTime !== void 0 ? We.updateTime(Kn(t3.updateTime)) : t3.exists !== void 0 ? We.exists(t3.exists) : We.none();
  }(e.currentDocument) : We.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      L2(e3.setToServerValue === "REQUEST_TIME"), n2 = new $e();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new Oe(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Me(t4);
    } else
      "increment" in e3 ? n2 = new Be(t3, e3.increment) : M2();
    const s2 = lt.fromServerFormat(e3.fieldPath);
    return new Ke(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Gn(t2, e.update.name), r = new Bt({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new ft(e2.map((t5) => lt.fromServerFormat(t5)));
      }(e.updateMask);
      return new en(i, r, t3, n, s);
    }
    return new tn(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Gn(t2, e.delete);
    return new on(s2, n);
  }
  if (e.verify) {
    const s2 = Gn(t2, e.verify);
    return new an(s2, n);
  }
  return M2();
}
function is(t2, e) {
  return t2 && t2.length > 0 ? (L2(e !== void 0), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? Kn(t4.updateTime) : Kn(e2);
    return n.isEqual(it.min()) && (n = Kn(e2)), new Qe(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function rs(t2, e) {
  return {
    documents: [zn(t2, e.path)]
  };
}
function os(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  e.collectionGroup !== null ? (n.parent = zn(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = zn(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (t3.length === 0)
      return;
    const e2 = t3.map((t4) => function(t5) {
      if (t5.op === "==") {
        if (Ft(t5.value))
          return {
            unaryFilter: {
              field: ws(t5.field),
              op: "IS_NAN"
            }
          };
        if (Ot(t5.value))
          return {
            unaryFilter: {
              field: ws(t5.field),
              op: "IS_NULL"
            }
          };
      } else if (t5.op === "!=") {
        if (Ft(t5.value))
          return {
            unaryFilter: {
              field: ws(t5.field),
              op: "IS_NOT_NAN"
            }
          };
        if (Ot(t5.value))
          return {
            unaryFilter: {
              field: ws(t5.field),
              op: "IS_NOT_NULL"
            }
          };
      }
      return {
        fieldFilter: {
          field: ws(t5.field),
          op: ds(t5.op),
          value: t5.value
        }
      };
    }(t4));
    if (e2.length === 1)
      return e2[0];
    return {
      compositeFilter: {
        op: "AND",
        filters: e2
      }
    };
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (t3.length === 0)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: ws(t5.field),
        direction: fs(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.D || It(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  return o !== null && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = hs(e.startAt)), e.endAt && (n.structuredQuery.endAt = hs(e.endAt)), n;
}
function as(t2) {
  let e = Hn(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    L2(s === 1);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = us(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new ae(_s(t4.field), function(t5) {
      switch (t5) {
        case "ASCENDING":
          return "asc";
        case "DESCENDING":
          return "desc";
        default:
          return;
      }
    }(t4.direction));
  }(t3)));
  let a = null;
  n.limit && (a = function(t3) {
    let e2;
    return e2 = typeof t3 == "object" ? t3.value : t3, It(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = ls(n.startAt));
  let u = null;
  return n.endAt && (u = ls(n.endAt)), fe(e, i, o, r, a, "F", c, u);
}
function cs(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return M2();
    }
  }(0, e.purpose);
  return n == null ? null : {
    "goog-listen-tags": n
  };
}
function us(t2) {
  return t2 ? t2.unaryFilter !== void 0 ? [gs(t2)] : t2.fieldFilter !== void 0 ? [ms(t2)] : t2.compositeFilter !== void 0 ? t2.compositeFilter.filters.map((t3) => us(t3)).reduce((t3, e) => t3.concat(e)) : M2() : [];
}
function hs(t2) {
  return {
    before: t2.before,
    values: t2.position
  };
}
function ls(t2) {
  const e = !!t2.before, n = t2.values || [];
  return new re(n, e);
}
function fs(t2) {
  return Fn[t2];
}
function ds(t2) {
  return Mn[t2];
}
function ws(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function _s(t2) {
  return lt.fromServerFormat(t2.fieldPath);
}
function ms(t2) {
  return Ht.create(_s(t2.fieldFilter.field), function(t3) {
    switch (t3) {
      case "EQUAL":
        return "==";
      case "NOT_EQUAL":
        return "!=";
      case "GREATER_THAN":
        return ">";
      case "GREATER_THAN_OR_EQUAL":
        return ">=";
      case "LESS_THAN":
        return "<";
      case "LESS_THAN_OR_EQUAL":
        return "<=";
      case "ARRAY_CONTAINS":
        return "array-contains";
      case "IN":
        return "in";
      case "NOT_IN":
        return "not-in";
      case "ARRAY_CONTAINS_ANY":
        return "array-contains-any";
      case "OPERATOR_UNSPECIFIED":
      default:
        return M2();
    }
  }(t2.fieldFilter.op), t2.fieldFilter.value);
}
function gs(t2) {
  switch (t2.unaryFilter.op) {
    case "IS_NAN":
      const e = _s(t2.unaryFilter.field);
      return Ht.create(e, "==", {
        doubleValue: NaN
      });
    case "IS_NULL":
      const n = _s(t2.unaryFilter.field);
      return Ht.create(n, "==", {
        nullValue: "NULL_VALUE"
      });
    case "IS_NOT_NAN":
      const s = _s(t2.unaryFilter.field);
      return Ht.create(s, "!=", {
        doubleValue: NaN
      });
    case "IS_NOT_NULL":
      const i = _s(t2.unaryFilter.field);
      return Ht.create(i, "!=", {
        nullValue: "NULL_VALUE"
      });
    case "OPERATOR_UNSPECIFIED":
    default:
      return M2();
  }
}
function ys(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function ps(t2) {
  return t2.length >= 4 && t2.get(0) === "projects" && t2.get(2) === "databases";
}
function Es(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = Is(e)), e = Ts(t2.get(n), e);
  return Is(e);
}
function Ts(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function Is(t2) {
  return t2 + "";
}
function As(t2) {
  const e = t2.length;
  if (L2(e >= 2), e === 2)
    return L2(t2.charAt(0) === "" && t2.charAt(1) === ""), ut.emptyPath();
  const n = e - 2, s = [];
  let i = "";
  for (let r = 0; r < e; ) {
    const e2 = t2.indexOf("", r);
    (e2 < 0 || e2 > n) && M2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const n2 = t2.substring(r, e2);
        let o;
        i.length === 0 ? o = n2 : (i += n2, o = i, i = ""), s.push(o);
        break;
      case "":
        i += t2.substring(r, e2), i += "\0";
        break;
      case "":
        i += t2.substring(r, e2 + 1);
        break;
      default:
        M2();
    }
    r = e2 + 2;
  }
  return new ut(s);
}
var Rs = class {
  constructor(t2, e) {
    this.seconds = t2, this.nanoseconds = e;
  }
};
var Ps = class {
  constructor(t2, e, n) {
    this.ownerId = t2, this.allowTabSynchronization = e, this.leaseTimestampMs = n;
  }
};
Ps.store = "owner", Ps.key = "owner";
var bs = class {
  constructor(t2, e, n) {
    this.userId = t2, this.lastAcknowledgedBatchId = e, this.lastStreamToken = n;
  }
};
bs.store = "mutationQueues", bs.keyPath = "userId";
var vs = class {
  constructor(t2, e, n, s, i) {
    this.userId = t2, this.batchId = e, this.localWriteTimeMs = n, this.baseMutations = s, this.mutations = i;
  }
};
vs.store = "mutations", vs.keyPath = "batchId", vs.userMutationsIndex = "userMutationsIndex", vs.userMutationsKeyPath = ["userId", "batchId"];
var Vs = class {
  constructor() {
  }
  static prefixForUser(t2) {
    return [t2];
  }
  static prefixForPath(t2, e) {
    return [t2, Es(e)];
  }
  static key(t2, e, n) {
    return [t2, Es(e), n];
  }
};
Vs.store = "documentMutations", Vs.PLACEHOLDER = new Vs();
var Ss = class {
  constructor(t2, e) {
    this.path = t2, this.readTime = e;
  }
};
var Ds = class {
  constructor(t2, e) {
    this.path = t2, this.version = e;
  }
};
var Cs = class {
  constructor(t2, e, n, s, i, r) {
    this.unknownDocument = t2, this.noDocument = e, this.document = n, this.hasCommittedMutations = s, this.readTime = i, this.parentPath = r;
  }
};
Cs.store = "remoteDocuments", Cs.readTimeIndex = "readTimeIndex", Cs.readTimeIndexPath = "readTime", Cs.collectionReadTimeIndex = "collectionReadTimeIndex", Cs.collectionReadTimeIndexPath = ["parentPath", "readTime"];
var Ns = class {
  constructor(t2) {
    this.byteSize = t2;
  }
};
Ns.store = "remoteDocumentGlobal", Ns.key = "remoteDocumentGlobalKey";
var xs = class {
  constructor(t2, e, n, s, i, r, o) {
    this.targetId = t2, this.canonicalId = e, this.readTime = n, this.resumeToken = s, this.lastListenSequenceNumber = i, this.lastLimboFreeSnapshotVersion = r, this.query = o;
  }
};
xs.store = "targets", xs.keyPath = "targetId", xs.queryTargetsIndexName = "queryTargetsIndex", xs.queryTargetsKeyPath = ["canonicalId", "targetId"];
var ks = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.path = e, this.sequenceNumber = n;
  }
};
ks.store = "targetDocuments", ks.keyPath = ["targetId", "path"], ks.documentTargetsIndex = "documentTargetsIndex", ks.documentTargetsKeyPath = ["path", "targetId"];
var $s = class {
  constructor(t2, e, n, s) {
    this.highestTargetId = t2, this.highestListenSequenceNumber = e, this.lastRemoteSnapshotVersion = n, this.targetCount = s;
  }
};
$s.key = "targetGlobalKey", $s.store = "targetGlobal";
var Os = class {
  constructor(t2, e) {
    this.collectionId = t2, this.parent = e;
  }
};
Os.store = "collectionParents", Os.keyPath = ["collectionId", "parent"];
var Fs = class {
  constructor(t2, e, n, s) {
    this.clientId = t2, this.updateTimeMs = e, this.networkEnabled = n, this.inForeground = s;
  }
};
Fs.store = "clientMetadata", Fs.keyPath = "clientId";
var Ms = class {
  constructor(t2, e, n) {
    this.bundleId = t2, this.createTime = e, this.version = n;
  }
};
Ms.store = "bundles", Ms.keyPath = "bundleId";
var Ls = class {
  constructor(t2, e, n) {
    this.name = t2, this.readTime = e, this.bundledQuery = n;
  }
};
Ls.store = "namedQueries", Ls.keyPath = "name";
var Bs = [...[...[...[...[bs.store, vs.store, Vs.store, Cs.store, xs.store, Ps.store, $s.store, ks.store], Fs.store], Ns.store], Os.store], Ms.store, Ls.store];
var Us = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var qs = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
var Ks = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && M2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new Ks((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof Ks ? e : Ks.resolve(e);
    } catch (t3) {
      return Ks.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Ks.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : Ks.reject(e);
  }
  static resolve(t2) {
    return new Ks((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new Ks((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new Ks((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = Ks.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? Ks.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
};
var js = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.Tt = new j(), this.transaction.oncomplete = () => {
      this.Tt.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.Tt.reject(new Gs(t2, e.error)) : this.Tt.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = Xs(e2.target.error);
      this.Tt.reject(new Gs(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new js(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Gs(e, t3);
    }
  }
  get It() {
    return this.Tt.promise;
  }
  abort(t2) {
    t2 && this.Tt.reject(t2), this.aborted || (k2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new Hs(e);
  }
};
var Qs = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.At = n;
    Qs.Rt(getUA()) === 12.2 && $("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return k2("SimpleDb", "Removing database:", t2), Js(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static Pt() {
    if (typeof indexedDB == "undefined")
      return false;
    if (Qs.bt())
      return true;
    const t2 = getUA(), e = Qs.Rt(t2), n = 0 < e && e < 10, s = Qs.vt(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static bt() {
    var t2;
    return typeof process != "undefined" && ((t2 = process.env) === null || t2 === void 0 ? void 0 : t2.Vt) === "YES";
  }
  static St(t2, e) {
    return t2.store(e);
  }
  static Rt(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static vt(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async Dt(t2) {
    return this.db || (k2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Gs(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        s2.name === "VersionError" ? n(new K2(q2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : n(new Gs(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        k2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.At.Ct(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          k2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.Nt && (this.db.onversionchange = (t3) => this.Nt(t3)), this.db;
  }
  xt(t2) {
    this.Nt = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = e === "readonly";
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.Dt(t2);
        const e2 = js.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).catch((t3) => (e2.abort(t3), Ks.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.It, r2;
      } catch (t3) {
        const e2 = t3.name !== "FirebaseError" && r < 3;
        if (k2("SimpleDb", "Transaction failed with error:", t3.message, "Retrying:", e2), this.close(), !e2)
          return Promise.reject(t3);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var Ws = class {
  constructor(t2) {
    this.kt = t2, this.$t = false, this.Ot = null;
  }
  get isDone() {
    return this.$t;
  }
  get Ft() {
    return this.Ot;
  }
  set cursor(t2) {
    this.kt = t2;
  }
  done() {
    this.$t = true;
  }
  Mt(t2) {
    this.Ot = t2;
  }
  delete() {
    return Js(this.kt.delete());
  }
};
var Gs = class extends K2 {
  constructor(t2, e) {
    super(q2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function zs(t2) {
  return t2.name === "IndexedDbTransactionError";
}
var Hs = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return e !== void 0 ? (k2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (k2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Js(n);
  }
  add(t2) {
    k2("SimpleDb", "ADD", this.store.name, t2, t2);
    return Js(this.store.add(t2));
  }
  get(t2) {
    return Js(this.store.get(t2)).next((e) => (e === void 0 && (e = null), k2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    k2("SimpleDb", "DELETE", this.store.name, t2);
    return Js(this.store.delete(t2));
  }
  count() {
    k2("SimpleDb", "COUNT", this.store.name);
    return Js(this.store.count());
  }
  Lt(t2, e) {
    const n = this.cursor(this.options(t2, e)), s = [];
    return this.Bt(n, (t3, e2) => {
      s.push(e2);
    }).next(() => s);
  }
  Ut(t2, e) {
    k2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.qt = false;
    const s = this.cursor(n);
    return this.Bt(s, (t3, e2, n2) => n2.delete());
  }
  Kt(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.Bt(s, e);
  }
  jt(t2) {
    const e = this.cursor({});
    return new Ks((n, s) => {
      e.onerror = (t3) => {
        const e2 = Xs(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  Bt(t2, e) {
    const n = [];
    return new Ks((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new Ws(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof Ks) {
          const t4 = o.catch((t5) => (r.done(), Ks.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : r.Ft === null ? i2.continue() : i2.continue(r.Ft);
      };
    }).next(() => Ks.waitFor(n));
  }
  options(t2, e) {
    let n;
    return t2 !== void 0 && (typeof t2 == "string" ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.qt ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Js(t2) {
  return new Ks((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = Xs(t3.target.error);
      n(e2);
    };
  });
}
var Ys = false;
function Xs(t2) {
  const e = Qs.Rt(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new K2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Ys || (Ys = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var Zs = class extends qs {
  constructor(t2, e) {
    super(), this.Qt = t2, this.currentSequenceNumber = e;
  }
};
function ti(t2, e) {
  const n = U2(t2);
  return Qs.St(n.Qt, e);
}
var ei = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        He(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2) {
    for (const e of this.baseMutations)
      e.key.isEqual(t2.key) && Je(e, t2, this.localWriteTime);
    for (const e of this.mutations)
      e.key.isEqual(t2.key) && Je(e, t2, this.localWriteTime);
  }
  applyToLocalDocumentSet(t2) {
    this.mutations.forEach((e) => {
      const n = t2.get(e.key), s = n;
      this.applyToLocalView(s), n.isValidDocument() || s.convertToNoDocument(it.min());
    });
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), Pn());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && et(this.mutations, t2.mutations, (t3, e) => Xe(t3, e)) && et(this.baseMutations, t2.baseMutations, (t3, e) => Xe(t3, e));
  }
};
var ni = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    L2(t2.mutations.length === n.length);
    let s = An();
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new ni(t2, e, n, s);
  }
};
var si = class {
  constructor(t2, e, n, s, i = it.min(), r = it.min(), o = wt.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new si(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new si(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new si(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var ii = class {
  constructor(t2) {
    this.Wt = t2;
  }
};
function ri(t2, e) {
  if (e.document)
    return Zn(t2.Wt, e.document, !!e.hasCommittedMutations);
  if (e.noDocument) {
    const t3 = Pt.fromSegments(e.noDocument.path), n = hi(e.noDocument.readTime), s = qt.newNoDocument(t3, n);
    return e.hasCommittedMutations ? s.setHasCommittedMutations() : s;
  }
  if (e.unknownDocument) {
    const t3 = Pt.fromSegments(e.unknownDocument.path), n = hi(e.unknownDocument.version);
    return qt.newUnknownDocument(t3, n);
  }
  return M2();
}
function oi(t2, e, n) {
  const s = ai(n), i = e.key.path.popLast().toArray();
  if (e.isFoundDocument()) {
    const n2 = function(t3, e2) {
      return {
        name: Wn(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Bn(t3, e2.version.toTimestamp())
      };
    }(t2.Wt, e), r = e.hasCommittedMutations;
    return new Cs(null, null, n2, r, s, i);
  }
  if (e.isNoDocument()) {
    const t3 = e.key.path.toArray(), n2 = ui(e.version), r = e.hasCommittedMutations;
    return new Cs(null, new Ss(t3, n2), null, r, s, i);
  }
  if (e.isUnknownDocument()) {
    const t3 = e.key.path.toArray(), n2 = ui(e.version);
    return new Cs(new Ds(t3, n2), null, null, true, s, i);
  }
  return M2();
}
function ai(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function ci(t2) {
  const e = new st(t2[0], t2[1]);
  return it.fromTimestamp(e);
}
function ui(t2) {
  const e = t2.toTimestamp();
  return new Rs(e.seconds, e.nanoseconds);
}
function hi(t2) {
  const e = new st(t2.seconds, t2.nanoseconds);
  return it.fromTimestamp(e);
}
function li(t2, e) {
  const n = (e.baseMutations || []).map((e2) => ss(t2.Wt, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && e.mutations[t3 + 1].transform !== void 0) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => ss(t2.Wt, e2)), i = st.fromMillis(e.localWriteTimeMs);
  return new ei(e.batchId, i, n, s);
}
function fi(t2) {
  const e = hi(t2.readTime), n = t2.lastLimboFreeSnapshotVersion !== void 0 ? hi(t2.lastLimboFreeSnapshotVersion) : it.min();
  let s;
  var i;
  return t2.query.documents !== void 0 ? (L2((i = t2.query).documents.length === 1), s = Ee(de(Hn(i.documents[0])))) : s = function(t3) {
    return Ee(as(t3));
  }(t2.query), new si(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, wt.fromBase64String(t2.resumeToken));
}
function di(t2, e) {
  const n = ui(e.snapshotVersion), s = ui(e.lastLimboFreeSnapshotVersion);
  let i;
  i = zt(e.target) ? rs(t2.Wt, e.target) : os(t2.Wt, e.target);
  const r = e.resumeToken.toBase64();
  return new xs(e.targetId, Qt(e.target), n, r, e.sequenceNumber, s, i);
}
function wi(t2) {
  const e = as({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return t2.limitType === "LAST" ? Te(e, e.limit, "L") : e;
}
var _i = class {
  getBundleMetadata(t2, e) {
    return mi(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: hi(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return mi(t2).put({
      bundleId: (n = e).id,
      createTime: ui(Kn(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return gi(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: wi(e2.bundledQuery),
          readTime: hi(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return gi(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: ui(Kn(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function mi(t2) {
  return ti(t2, Ms.store);
}
function gi(t2) {
  return ti(t2, Ls.store);
}
var yi = class {
  constructor() {
    this.Gt = new pi();
  }
  addToCollectionParentIndex(t2, e) {
    return this.Gt.add(e), Ks.resolve();
  }
  getCollectionParents(t2, e) {
    return Ks.resolve(this.Gt.getEntries(e));
  }
};
var pi = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new mn(ut.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new mn(ut.comparator)).toArray();
  }
};
var Ei = class {
  constructor() {
    this.zt = new pi();
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.zt.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.zt.add(e);
      });
      const i = {
        collectionId: n,
        parent: Es(s)
      };
      return Ti(t2).put(i);
    }
    return Ks.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound([e, ""], [nt(e), ""], false, true);
    return Ti(t2).Lt(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(As(s2.parent));
      }
      return n;
    });
  }
};
function Ti(t2) {
  return ti(t2, Os.store);
}
var Ii = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Ai = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Ai(t2, Ai.DEFAULT_COLLECTION_PERCENTILE, Ai.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function Ri(t2, e, n) {
  const s = t2.store(vs.store), i = t2.store(Vs.store), r = [], o = IDBKeyRange.only(n.batchId);
  let a = 0;
  const c = s.Kt({
    range: o
  }, (t3, e2, n2) => (a++, n2.delete()));
  r.push(c.next(() => {
    L2(a === 1);
  }));
  const u = [];
  for (const t3 of n.mutations) {
    const s2 = Vs.key(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), u.push(t3.key);
  }
  return Ks.waitFor(r).next(() => u);
}
function Pi(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw M2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Ai.DEFAULT_COLLECTION_PERCENTILE = 10, Ai.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Ai.DEFAULT = new Ai(41943040, Ai.DEFAULT_COLLECTION_PERCENTILE, Ai.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Ai.DISABLED = new Ai(-1, 0, 0);
var bi = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.N = e, this.Ht = n, this.referenceDelegate = s, this.Jt = {};
  }
  static Yt(t2, e, n, s) {
    L2(t2.uid !== "");
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new bi(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return Vi(t2).Kt({
      index: vs.userMutationsIndex,
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = Si(t2), r = Vi(t2);
    return r.add({}).next((o) => {
      L2(typeof o == "number");
      const a = new ei(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => ns(t3.Wt, e3)), i2 = n2.mutations.map((e3) => ns(t3.Wt, e3));
        return new vs(e2, n2.batchId, n2.localWriteTime.toMillis(), s2, i2);
      }(this.N, this.userId, a), u = [];
      let h = new mn((t3, e2) => tt(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Vs.key(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), u.push(r.put(c)), u.push(i.put(e2, Vs.PLACEHOLDER));
      }
      return h.forEach((e2) => {
        u.push(this.Ht.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.Jt[o] = a.keys();
      }), Ks.waitFor(u).next(() => a);
    });
  }
  lookupMutationBatch(t2, e) {
    return Vi(t2).get(e).next((t3) => t3 ? (L2(t3.userId === this.userId), li(this.N, t3)) : null);
  }
  Xt(t2, e) {
    return this.Jt[e] ? Ks.resolve(this.Jt[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.Jt[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return Vi(t2).Kt({
      index: vs.userMutationsIndex,
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && (L2(e2.batchId >= n), i = li(this.N, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return Vi(t2).Kt({
      index: vs.userMutationsIndex,
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return Vi(t2).Lt(vs.userMutationsIndex, e).next((t3) => t3.map((t4) => li(this.N, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Vs.prefixForPath(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return Si(t2).Kt({
      range: s
    }, (n2, s2, r) => {
      const [o, a, c] = n2, u = As(a);
      if (o === this.userId && e.path.isEqual(u))
        return Vi(t2).get(c).next((t3) => {
          if (!t3)
            throw M2();
          L2(t3.userId === this.userId), i.push(li(this.N, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new mn(tt);
    const s = [];
    return e.forEach((e2) => {
      const i = Vs.prefixForPath(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = Si(t2).Kt({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, a] = t3, c = As(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(a) : i2.done();
      });
      s.push(o);
    }), Ks.waitFor(s).next(() => this.Zt(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Vs.prefixForPath(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new mn(tt);
    return Si(t2).Kt({
      range: r
    }, (t3, e2, i2) => {
      const [r2, a, c] = t3, u = As(a);
      r2 === this.userId && n.isPrefixOf(u) ? u.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.Zt(t2, o));
  }
  Zt(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(Vi(t2).get(e2).next((t3) => {
        if (t3 === null)
          throw M2();
        L2(t3.userId === this.userId), n.push(li(this.N, t3));
      }));
    }), Ks.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return Ri(t2.Qt, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.te(e.batchId);
    }), Ks.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  te(t2) {
    delete this.Jt[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return Ks.resolve();
      const n = IDBKeyRange.lowerBound(Vs.prefixForUser(this.userId)), s = [];
      return Si(t2).Kt({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = As(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        L2(s.length === 0);
      });
    });
  }
  containsKey(t2, e) {
    return vi(t2, this.userId, e);
  }
  ee(t2) {
    return Di(t2).get(this.userId).next((t3) => t3 || new bs(this.userId, -1, ""));
  }
};
function vi(t2, e, n) {
  const s = Vs.prefixForPath(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return Si(t2).Kt({
    range: r,
    qt: true
  }, (t3, n2, s2) => {
    const [r2, a, c] = t3;
    r2 === e && a === i && (o = true), s2.done();
  }).next(() => o);
}
function Vi(t2) {
  return ti(t2, vs.store);
}
function Si(t2) {
  return ti(t2, Vs.store);
}
function Di(t2) {
  return ti(t2, bs.store);
}
var Ci = class {
  constructor(t2) {
    this.ne = t2;
  }
  next() {
    return this.ne += 2, this.ne;
  }
  static se() {
    return new Ci(0);
  }
  static ie() {
    return new Ci(-1);
  }
};
var Ni = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.N = e;
  }
  allocateTargetId(t2) {
    return this.re(t2).next((e) => {
      const n = new Ci(e.highestTargetId);
      return e.highestTargetId = n.next(), this.oe(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.re(t2).next((t3) => it.fromTimestamp(new st(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.re(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.re(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.oe(t2, s)));
  }
  addTargetData(t2, e) {
    return this.ae(t2, e).next(() => this.re(t2).next((n) => (n.targetCount += 1, this.ce(e, n), this.oe(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.ae(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => xi(t2).delete(e.targetId)).next(() => this.re(t2)).next((e2) => (L2(e2.targetCount > 0), e2.targetCount -= 1, this.oe(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return xi(t2).Kt((r, o) => {
      const a = fi(o);
      a.sequenceNumber <= e && n.get(a.targetId) === null && (s++, i.push(this.removeTargetData(t2, a)));
    }).next(() => Ks.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return xi(t2).Kt((t3, n) => {
      const s = fi(n);
      e(s);
    });
  }
  re(t2) {
    return ki(t2).get($s.key).next((t3) => (L2(t3 !== null), t3));
  }
  oe(t2, e) {
    return ki(t2).put($s.key, e);
  }
  ae(t2, e) {
    return xi(t2).put(di(this.N, e));
  }
  ce(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.re(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Qt(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return xi(t2).Kt({
      range: s,
      index: xs.queryTargetsIndexName
    }, (t3, n2, s2) => {
      const r = fi(n2);
      Gt(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = $i(t2);
    return e.forEach((e2) => {
      const r = Es(e2.path);
      s.push(i.put(new ks(n, r))), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), Ks.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = $i(t2);
    return Ks.forEach(e, (e2) => {
      const i = Es(e2.path);
      return Ks.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = $i(t2), s = IDBKeyRange.bound([e], [e + 1], false, true);
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound([e], [e + 1], false, true), s = $i(t2);
    let i = Pn();
    return s.Kt({
      range: n,
      qt: true
    }, (t3, e2, n2) => {
      const s2 = As(t3[1]), r = new Pt(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Es(e.path), s = IDBKeyRange.bound([n], [nt(n)], false, true);
    let i = 0;
    return $i(t2).Kt({
      index: ks.documentTargetsIndex,
      qt: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      t3 !== 0 && (i++, s2.done());
    }).next(() => i > 0);
  }
  Et(t2, e) {
    return xi(t2).get(e).next((t3) => t3 ? fi(t3) : null);
  }
};
function xi(t2) {
  return ti(t2, xs.store);
}
function ki(t2) {
  return ti(t2, $s.store);
}
function $i(t2) {
  return ti(t2, ks.store);
}
async function Oi(t2) {
  if (t2.code !== q2.FAILED_PRECONDITION || t2.message !== Us)
    throw t2;
  k2("LocalStore", "Unexpectedly lost primary lease");
}
function Fi([t2, e], [n, s]) {
  const i = tt(t2, n);
  return i === 0 ? tt(e, s) : i;
}
var Mi = class {
  constructor(t2) {
    this.ue = t2, this.buffer = new mn(Fi), this.he = 0;
  }
  le() {
    return ++this.he;
  }
  fe(t2) {
    const e = [t2, this.le()];
    if (this.buffer.size < this.ue)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      Fi(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var Li = class {
  constructor(t2, e) {
    this.garbageCollector = t2, this.asyncQueue = e, this.de = false, this.we = null;
  }
  start(t2) {
    this.garbageCollector.params.cacheSizeCollectionThreshold !== -1 && this._e(t2);
  }
  stop() {
    this.we && (this.we.cancel(), this.we = null);
  }
  get started() {
    return this.we !== null;
  }
  _e(t2) {
    const e = this.de ? 3e5 : 6e4;
    k2("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.we = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, async () => {
      this.we = null, this.de = true;
      try {
        await t2.collectGarbage(this.garbageCollector);
      } catch (t3) {
        zs(t3) ? k2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Oi(t3);
      }
      await this._e(t2);
    });
  }
};
var Bi = class {
  constructor(t2, e) {
    this.me = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.me.ge(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (e === 0)
      return Ks.resolve(Y2.T);
    const n = new Mi(e);
    return this.me.forEachTarget(t2, (t3) => n.fe(t3.sequenceNumber)).next(() => this.me.ye(t2, (t3) => n.fe(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.me.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.me.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return this.params.cacheSizeCollectionThreshold === -1 ? (k2("LruGarbageCollector", "Garbage collection skipped; disabled"), Ks.resolve(Ii)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (k2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), Ii) : this.pe(t2, e));
  }
  getCacheSize(t2) {
    return this.me.getCacheSize(t2);
  }
  pe(t2, e) {
    let n, s, i, r, o, a, u;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (k2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, a = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (u = Date.now(), N2() <= LogLevel.DEBUG) {
        k2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (a - o) + `ms
	Removed ${t3} documents in ` + (u - a) + `ms
Total Duration: ${u - h}ms`);
      }
      return Ks.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var Ui = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new Bi(t3, e2);
    }(this, e);
  }
  ge(t2) {
    const e = this.Ee(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  Ee(t2) {
    let e = 0;
    return this.ye(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  ye(t2, e) {
    return this.Te(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return qi(t2, n);
  }
  removeReference(t2, e, n) {
    return qi(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return qi(t2, e);
  }
  Ie(t2, e) {
    return function(t3, e2) {
      let n = false;
      return Di(t3).jt((s) => vi(t3, s, e2).next((t4) => (t4 && (n = true), Ks.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Te(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Ie(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r), $i(t2).delete([0, Es(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => Ks.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return qi(t2, e);
  }
  Te(t2, e) {
    const n = $i(t2);
    let s, i = Y2.T;
    return n.Kt({
      index: ks.documentTargetsIndex
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      t3 === 0 ? (i !== Y2.T && e(new Pt(As(s)), i), i = o, s = r) : i = Y2.T;
    }).next(() => {
      i !== Y2.T && e(new Pt(As(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function qi(t2, e) {
  return $i(t2).put(function(t3, e2) {
    return new ks(0, Es(t3.path), e2);
  }(e, t2.currentSequenceNumber));
}
var Ki = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {};
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n !== void 0) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return this.get(t2) !== void 0;
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (s !== void 0) {
      for (let n2 = 0; n2 < s.length; n2++)
        if (this.equalsFn(s[n2][0], t2))
          return void (s[n2] = [t2, e]);
      s.push([t2, e]);
    } else
      this.inner[n] = [[t2, e]];
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (n === void 0)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return n.length === 1 ? delete this.inner[e] : n.splice(s, 1), true;
    return false;
  }
  forEach(t2) {
    ot(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return at(this.inner);
  }
};
var ji = class {
  constructor() {
    this.changes = new Ki((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  getReadTime(t2) {
    const e = this.changes.get(t2);
    return e ? e.readTime : it.min();
  }
  addEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2.key, {
      document: t2,
      readTime: e
    });
  }
  removeEntry(t2, e = null) {
    this.assertNotApplied(), this.changes.set(t2, {
      document: qt.newInvalidDocument(t2),
      readTime: e
    });
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return n !== void 0 ? Ks.resolve(n.document) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var Qi = class {
  constructor(t2, e) {
    this.N = t2, this.Ht = e;
  }
  addEntry(t2, e, n) {
    return zi(t2).put(Hi(e), n);
  }
  removeEntry(t2, e) {
    const n = zi(t2), s = Hi(e);
    return n.delete(s);
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Ae(t2, n)));
  }
  getEntry(t2, e) {
    return zi(t2).get(Hi(e)).next((t3) => this.Re(e, t3));
  }
  Pe(t2, e) {
    return zi(t2).get(Hi(e)).next((t3) => ({
      document: this.Re(e, t3),
      size: Pi(t3)
    }));
  }
  getEntries(t2, e) {
    let n = pn();
    return this.be(t2, e, (t3, e2) => {
      const s = this.Re(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  ve(t2, e) {
    let n = pn(), s = new dn(Pt.comparator);
    return this.be(t2, e, (t3, e2) => {
      const i = this.Re(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Pi(e2));
    }).next(() => ({
      documents: n,
      Ve: s
    }));
  }
  be(t2, e, n) {
    if (e.isEmpty())
      return Ks.resolve();
    const s = IDBKeyRange.bound(e.first().path.toArray(), e.last().path.toArray()), i = e.getIterator();
    let r = i.getNext();
    return zi(t2).Kt({
      range: s
    }, (t3, e2, s2) => {
      const o = Pt.fromSegments(t3);
      for (; r && Pt.comparator(r, o) < 0; )
        n(r, null), r = i.getNext();
      r && r.isEqual(o) && (n(r, e2), r = i.hasNext() ? i.getNext() : null), r ? s2.Mt(r.path.toArray()) : s2.done();
    }).next(() => {
      for (; r; )
        n(r, null), r = i.hasNext() ? i.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = pn();
    const i = e.path.length + 1, r = {};
    if (n.isEqual(it.min())) {
      const t3 = e.path.toArray();
      r.range = IDBKeyRange.lowerBound(t3);
    } else {
      const t3 = e.path.toArray(), s2 = ai(n);
      r.range = IDBKeyRange.lowerBound([t3, s2], true), r.index = Cs.collectionReadTimeIndex;
    }
    return zi(t2).Kt(r, (t3, n2, r2) => {
      if (t3.length !== i)
        return;
      const o = ri(this.N, n2);
      e.path.isPrefixOf(o.key.path) ? Pe(e, o) && (s = s.insert(o.key, o)) : r2.done();
    }).next(() => s);
  }
  newChangeBuffer(t2) {
    return new Wi(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return Gi(t2).get(Ns.key).next((t3) => (L2(!!t3), t3));
  }
  Ae(t2, e) {
    return Gi(t2).put(Ns.key, e);
  }
  Re(t2, e) {
    if (e) {
      const t3 = ri(this.N, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(it.min())))
        return t3;
    }
    return qt.newInvalidDocument(t2);
  }
};
var Wi = class extends ji {
  constructor(t2, e) {
    super(), this.Se = t2, this.trackRemovals = e, this.De = new Ki((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new mn((t3, e2) => tt(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.De.get(i);
      if (r.document.isValidDocument()) {
        const a = oi(this.Se.N, r.document, this.getReadTime(i));
        s = s.add(i.path.popLast());
        const c = Pi(a);
        n += c - o, e.push(this.Se.addEntry(t2, i, a));
      } else if (n -= o, this.trackRemovals) {
        const n2 = oi(this.Se.N, qt.newNoDocument(i, it.min()), this.getReadTime(i));
        e.push(this.Se.addEntry(t2, i, n2));
      } else
        e.push(this.Se.removeEntry(t2, i));
    }), s.forEach((n2) => {
      e.push(this.Se.Ht.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Se.updateMetadata(t2, n)), Ks.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Se.Pe(t2, e).next((t3) => (this.De.set(e, t3.size), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Se.ve(t2, e).next(({ documents: t3, Ve: e2 }) => (e2.forEach((t4, e3) => {
      this.De.set(t4, e3);
    }), t3));
  }
};
function Gi(t2) {
  return ti(t2, Ns.store);
}
function zi(t2) {
  return ti(t2, Cs.store);
}
function Hi(t2) {
  return t2.path.toArray();
}
var Ji = class {
  constructor(t2) {
    this.N = t2;
  }
  Ct(t2, e, n, s) {
    L2(n < s && n >= 0 && s <= 11);
    const i = new js("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore(Ps.store);
    }(t2), function(t3) {
      t3.createObjectStore(bs.store, {
        keyPath: bs.keyPath
      });
      t3.createObjectStore(vs.store, {
        keyPath: vs.keyPath,
        autoIncrement: true
      }).createIndex(vs.userMutationsIndex, vs.userMutationsKeyPath, {
        unique: true
      }), t3.createObjectStore(Vs.store);
    }(t2), Yi(t2), function(t3) {
      t3.createObjectStore(Cs.store);
    }(t2));
    let r = Ks.resolve();
    return n < 3 && s >= 3 && (n !== 0 && (!function(t3) {
      t3.deleteObjectStore(ks.store), t3.deleteObjectStore(xs.store), t3.deleteObjectStore($s.store);
    }(t2), Yi(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store($s.store), n2 = new $s(0, 0, it.min().toTimestamp(), 0);
      return e2.put($s.key, n2);
    }(i))), n < 4 && s >= 4 && (n !== 0 && (r = r.next(() => function(t3, e2) {
      return e2.store(vs.store).Lt().next((n2) => {
        t3.deleteObjectStore(vs.store);
        t3.createObjectStore(vs.store, {
          keyPath: vs.keyPath,
          autoIncrement: true
        }).createIndex(vs.userMutationsIndex, vs.userMutationsKeyPath, {
          unique: true
        });
        const s2 = e2.store(vs.store), i2 = n2.map((t4) => s2.put(t4));
        return Ks.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Fs.store, {
          keyPath: Fs.keyPath
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.Ce(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore(Ns.store);
    }(t2), this.Ne(i)))), n < 7 && s >= 7 && (r = r.next(() => this.xe(i))), n < 8 && s >= 8 && (r = r.next(() => this.ke(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2), function(t3) {
        const e2 = t3.objectStore(Cs.store);
        e2.createIndex(Cs.readTimeIndex, Cs.readTimeIndexPath, {
          unique: false
        }), e2.createIndex(Cs.collectionReadTimeIndex, Cs.collectionReadTimeIndexPath, {
          unique: false
        });
      }(e);
    })), n < 10 && s >= 10 && (r = r.next(() => this.$e(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore(Ms.store, {
          keyPath: Ms.keyPath
        });
      }(t2), function(t3) {
        t3.createObjectStore(Ls.store, {
          keyPath: Ls.keyPath
        });
      }(t2);
    })), r;
  }
  Ne(t2) {
    let e = 0;
    return t2.store(Cs.store).Kt((t3, n) => {
      e += Pi(n);
    }).next(() => {
      const n = new Ns(e);
      return t2.store(Ns.store).put(Ns.key, n);
    });
  }
  Ce(t2) {
    const e = t2.store(bs.store), n = t2.store(vs.store);
    return e.Lt().next((e2) => Ks.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.Lt(vs.userMutationsIndex, s).next((n2) => Ks.forEach(n2, (n3) => {
        L2(n3.userId === e3.userId);
        const s2 = li(this.N, n3);
        return Ri(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  xe(t2) {
    const e = t2.store(ks.store), n = t2.store(Cs.store);
    return t2.store($s.store).get($s.key).next((t3) => {
      const s = [];
      return n.Kt((n2, i) => {
        const r = new ut(n2), o = function(t4) {
          return [0, Es(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? Ks.resolve() : ((n4) => e.put(new ks(0, Es(n4), t3.highestListenSequenceNumber)))(r)));
      }).next(() => Ks.waitFor(s));
    });
  }
  ke(t2, e) {
    t2.createObjectStore(Os.store, {
      keyPath: Os.keyPath
    });
    const n = e.store(Os.store), s = new pi(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Es(s2)
        });
      }
    };
    return e.store(Cs.store).Kt({
      qt: true
    }, (t3, e2) => {
      const n2 = new ut(t3);
      return i(n2.popLast());
    }).next(() => e.store(Vs.store).Kt({
      qt: true
    }, ([t3, e2, n2], s2) => {
      const r = As(e2);
      return i(r.popLast());
    }));
  }
  $e(t2) {
    const e = t2.store(xs.store);
    return e.Kt((t3, n) => {
      const s = fi(n), i = di(this.N, s);
      return e.put(i);
    });
  }
};
function Yi(t2) {
  t2.createObjectStore(ks.store, {
    keyPath: ks.keyPath
  }).createIndex(ks.documentTargetsIndex, ks.documentTargetsKeyPath, {
    unique: true
  });
  t2.createObjectStore(xs.store, {
    keyPath: xs.keyPath
  }).createIndex(xs.queryTargetsIndexName, xs.queryTargetsKeyPath, {
    unique: true
  }), t2.createObjectStore($s.store);
}
var Xi = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Zi = class {
  constructor(t2, e, n, s, i, r, o, a, c, u) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Oe = i, this.window = r, this.document = o, this.Fe = c, this.Me = u, this.Le = null, this.Be = false, this.isPrimary = false, this.networkEnabled = true, this.Ue = null, this.inForeground = false, this.qe = null, this.Ke = null, this.je = Number.NEGATIVE_INFINITY, this.Qe = (t3) => Promise.resolve(), !Zi.Pt())
      throw new K2(q2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new Ui(this, s), this.We = e + "main", this.N = new ii(a), this.Ge = new Qs(this.We, 11, new Ji(this.N)), this.ze = new Ni(this.referenceDelegate, this.N), this.Ht = new Ei(), this.He = function(t3, e2) {
      return new Qi(t3, e2);
    }(this.N, this.Ht), this.Je = new _i(), this.window && this.window.localStorage ? this.Ye = this.window.localStorage : (this.Ye = null, u === false && $("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.Xe().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new K2(q2.FAILED_PRECONDITION, Xi);
      return this.Ze(), this.tn(), this.en(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.ze.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Le = new Y2(t2, this.Fe);
    }).then(() => {
      this.Be = true;
    }).catch((t2) => (this.Ge && this.Ge.close(), Promise.reject(t2)));
  }
  nn(t2) {
    return this.Qe = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.Ge.xt(async (e) => {
      e.newVersion === null && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Oe.enqueueAndForget(async () => {
      this.started && await this.Xe();
    }));
  }
  Xe() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => er(t2).put(new Fs(this.clientId, Date.now(), this.networkEnabled, this.inForeground)).next(() => {
      if (this.isPrimary)
        return this.sn(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Oe.enqueueRetryable(() => this.Qe(false)));
        });
    }).next(() => this.rn(t2)).next((e) => this.isPrimary && !e ? this.on(t2).next(() => false) : !!e && this.an(t2).next(() => true))).catch((t2) => {
      if (zs(t2))
        return k2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return k2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Oe.enqueueRetryable(() => this.Qe(t2)), this.isPrimary = t2;
    });
  }
  sn(t2) {
    return tr(t2).get(Ps.key).next((t3) => Ks.resolve(this.cn(t3)));
  }
  un(t2) {
    return er(t2).delete(this.clientId);
  }
  async hn() {
    if (this.isPrimary && !this.ln(this.je, 18e5)) {
      this.je = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = ti(t3, Fs.store);
        return e.Lt().next((t4) => {
          const n = this.fn(t4, 18e5), s = t4.filter((t5) => n.indexOf(t5) === -1);
          return Ks.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.Ye)
        for (const e of t2)
          this.Ye.removeItem(this.dn(e.clientId));
    }
  }
  en() {
    this.Ke = this.Oe.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.Xe().then(() => this.hn()).then(() => this.en()));
  }
  cn(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  rn(t2) {
    if (this.Me)
      return Ks.resolve(true);
    return tr(t2).get(Ps.key).next((e) => {
      if (e !== null && this.ln(e.leaseTimestampMs, 5e3) && !this.wn(e.ownerId)) {
        if (this.cn(e) && this.networkEnabled)
          return true;
        if (!this.cn(e)) {
          if (!e.allowTabSynchronization)
            throw new K2(q2.FAILED_PRECONDITION, Xi);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || er(t2).Lt().next((t3) => this.fn(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }) === void 0);
    }).next((t3) => (this.isPrimary !== t3 && k2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Be = false, this._n(), this.Ke && (this.Ke.cancel(), this.Ke = null), this.mn(), this.gn(), await this.Ge.runTransaction("shutdown", "readwrite", [Ps.store, Fs.store], (t2) => {
      const e = new Zs(t2, Y2.T);
      return this.on(e).next(() => this.un(e));
    }), this.Ge.close(), this.yn();
  }
  fn(t2, e) {
    return t2.filter((t3) => this.ln(t3.updateTimeMs, e) && !this.wn(t3.clientId));
  }
  pn() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => er(t2).Lt().next((t3) => this.fn(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Be;
  }
  getMutationQueue(t2) {
    return bi.Yt(t2, this.N, this.Ht, this.referenceDelegate);
  }
  getTargetCache() {
    return this.ze;
  }
  getRemoteDocumentCache() {
    return this.He;
  }
  getIndexManager() {
    return this.Ht;
  }
  getBundleCache() {
    return this.Je;
  }
  runTransaction(t2, e, n) {
    k2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = e === "readonly" ? "readonly" : "readwrite";
    let i;
    return this.Ge.runTransaction(t2, s, Bs, (s2) => (i = new Zs(s2, this.Le ? this.Le.next() : Y2.T), e === "readwrite-primary" ? this.sn(i).next((t3) => !!t3 || this.rn(i)).next((e2) => {
      if (!e2)
        throw $(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Oe.enqueueRetryable(() => this.Qe(false)), new K2(q2.FAILED_PRECONDITION, Us);
      return n(i);
    }).next((t3) => this.an(i).next(() => t3)) : this.En(i).next(() => n(i)))).then((t3) => (i.raiseOnCommittedEvent(), t3));
  }
  En(t2) {
    return tr(t2).get(Ps.key).next((t3) => {
      if (t3 !== null && this.ln(t3.leaseTimestampMs, 5e3) && !this.wn(t3.ownerId) && !this.cn(t3) && !(this.Me || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new K2(q2.FAILED_PRECONDITION, Xi);
    });
  }
  an(t2) {
    const e = new Ps(this.clientId, this.allowTabSynchronization, Date.now());
    return tr(t2).put(Ps.key, e);
  }
  static Pt() {
    return Qs.Pt();
  }
  on(t2) {
    const e = tr(t2);
    return e.get(Ps.key).next((t3) => this.cn(t3) ? (k2("IndexedDbPersistence", "Releasing primary lease."), e.delete(Ps.key)) : Ks.resolve());
  }
  ln(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || ($(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  Ze() {
    this.document !== null && typeof this.document.addEventListener == "function" && (this.qe = () => {
      this.Oe.enqueueAndForget(() => (this.inForeground = this.document.visibilityState === "visible", this.Xe()));
    }, this.document.addEventListener("visibilitychange", this.qe), this.inForeground = this.document.visibilityState === "visible");
  }
  mn() {
    this.qe && (this.document.removeEventListener("visibilitychange", this.qe), this.qe = null);
  }
  tn() {
    var t2;
    typeof ((t2 = this.window) === null || t2 === void 0 ? void 0 : t2.addEventListener) == "function" && (this.Ue = () => {
      this._n(), isSafari() && navigator.appVersion.match("Version/14") && this.Oe.enterRestrictedMode(true), this.Oe.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Ue));
  }
  gn() {
    this.Ue && (this.window.removeEventListener("pagehide", this.Ue), this.Ue = null);
  }
  wn(t2) {
    var e;
    try {
      const n = ((e = this.Ye) === null || e === void 0 ? void 0 : e.getItem(this.dn(t2))) !== null;
      return k2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return $("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  _n() {
    if (this.Ye)
      try {
        this.Ye.setItem(this.dn(this.clientId), String(Date.now()));
      } catch (t2) {
        $("Failed to set zombie client id.", t2);
      }
  }
  yn() {
    if (this.Ye)
      try {
        this.Ye.removeItem(this.dn(this.clientId));
      } catch (t2) {
      }
  }
  dn(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function tr(t2) {
  return ti(t2, Ps.store);
}
function er(t2) {
  return ti(t2, Fs.store);
}
function nr(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var sr = class {
  constructor(t2, e) {
    this.progress = t2, this.Tn = e;
  }
};
var ir = class {
  constructor(t2, e, n) {
    this.He = t2, this.In = e, this.Ht = n;
  }
  An(t2, e) {
    return this.In.getAllMutationBatchesAffectingDocumentKey(t2, e).next((n) => this.Rn(t2, e, n));
  }
  Rn(t2, e, n) {
    return this.He.getEntry(t2, e).next((t3) => {
      for (const e2 of n)
        e2.applyToLocalView(t3);
      return t3;
    });
  }
  Pn(t2, e) {
    t2.forEach((t3, n) => {
      for (const t4 of e)
        t4.applyToLocalView(n);
    });
  }
  bn(t2, e) {
    return this.He.getEntries(t2, e).next((e2) => this.vn(t2, e2).next(() => e2));
  }
  vn(t2, e) {
    return this.In.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => this.Pn(e, t3));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return Pt.isDocumentKey(t3.path) && t3.collectionGroup === null && t3.filters.length === 0;
    }(e) ? this.Vn(t2, e.path) : ye(e) ? this.Sn(t2, e, n) : this.Dn(t2, e, n);
  }
  Vn(t2, e) {
    return this.An(t2, new Pt(e)).next((t3) => {
      let e2 = Tn();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  Sn(t2, e, n) {
    const s = e.collectionGroup;
    let i = Tn();
    return this.Ht.getCollectionParents(t2, s).next((r) => Ks.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new le(e2, null, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
      }(e, r2.child(s));
      return this.Dn(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  Dn(t2, e, n) {
    let s, i;
    return this.He.getDocumentsMatchingQuery(t2, e, n).next((n2) => (s = n2, this.In.getAllMutationBatchesAffectingQuery(t2, e))).next((e2) => (i = e2, this.Cn(t2, i, s).next((t3) => {
      s = t3;
      for (const t4 of i)
        for (const e3 of t4.mutations) {
          const n2 = e3.key;
          let i2 = s.get(n2);
          i2 == null && (i2 = qt.newInvalidDocument(n2), s = s.insert(n2, i2)), Je(e3, i2, t4.localWriteTime), i2.isFoundDocument() || (s = s.remove(n2));
        }
    }))).next(() => (s.forEach((t3, n2) => {
      Pe(e, n2) || (s = s.remove(t3));
    }), s));
  }
  Cn(t2, e, n) {
    let s = Pn();
    for (const t3 of e)
      for (const e2 of t3.mutations)
        e2 instanceof en && n.get(e2.key) === null && (s = s.add(e2.key));
    let i = n;
    return this.He.getEntries(t2, s).next((t3) => (t3.forEach((t4, e2) => {
      e2.isFoundDocument() && (i = i.insert(t4, e2));
    }), i));
  }
};
var rr = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Nn = n, this.xn = s;
  }
  static kn(t2, e) {
    let n = Pn(), s = Pn();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new rr(t2, e.fromCache, n, s);
  }
};
var or = class {
  $n(t2) {
    this.On = t2;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return function(t3) {
      return t3.filters.length === 0 && t3.limit === null && t3.startAt == null && t3.endAt == null && (t3.explicitOrderBy.length === 0 || t3.explicitOrderBy.length === 1 && t3.explicitOrderBy[0].field.isKeyField());
    }(e) || n.isEqual(it.min()) ? this.Fn(t2, e) : this.On.bn(t2, s).next((i) => {
      const r = this.Mn(e, i);
      return (we(e) || _e(e)) && this.Ln(e.limitType, r, s, n) ? this.Fn(t2, e) : (N2() <= LogLevel.DEBUG && k2("QueryEngine", "Re-using previous result from %s to execute query: %s", n.toString(), Re(e)), this.On.getDocumentsMatchingQuery(t2, e, n).next((t3) => (r.forEach((e2) => {
        t3 = t3.insert(e2.key, e2);
      }), t3)));
    });
  }
  Mn(t2, e) {
    let n = new mn(be(t2));
    return e.forEach((e2, s) => {
      Pe(t2, s) && (n = n.add(s));
    }), n;
  }
  Ln(t2, e, n, s) {
    if (n.size !== e.size)
      return true;
    const i = t2 === "F" ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Fn(t2, e) {
    return N2() <= LogLevel.DEBUG && k2("QueryEngine", "Using full collection scan to execute query:", Re(e)), this.On.getDocumentsMatchingQuery(t2, e, it.min());
  }
};
var ar = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Bn = e, this.N = s, this.Un = new dn(tt), this.qn = new Ki((t3) => Qt(t3), Gt), this.Kn = it.min(), this.In = t2.getMutationQueue(n), this.jn = t2.getRemoteDocumentCache(), this.ze = t2.getTargetCache(), this.Qn = new ir(this.jn, this.In, this.persistence.getIndexManager()), this.Je = t2.getBundleCache(), this.Bn.$n(this.Qn);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Un));
  }
};
function cr(t2, e, n, s) {
  return new ar(t2, e, n, s);
}
async function ur(t2, e) {
  const n = U2(t2);
  let s = n.In, i = n.Qn;
  const r = await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let r2;
    return n.In.getAllMutationBatches(t3).next((o) => (r2 = o, s = n.persistence.getMutationQueue(e), i = new ir(n.jn, s, n.persistence.getIndexManager()), s.getAllMutationBatches(t3))).next((e2) => {
      const n2 = [], s2 = [];
      let o = Pn();
      for (const t4 of r2) {
        n2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        s2.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return i.bn(t3, o).next((t4) => ({
        Wn: t4,
        removedBatchIds: n2,
        addedBatchIds: s2
      }));
    });
  });
  return n.In = s, n.Qn = i, n.Bn.$n(n.Qn), r;
}
function hr(t2, e) {
  const n = U2(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = Ks.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          L2(r2 !== null), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && s2.addEntry(e3, n2.commitVersion));
        });
      }), o.next(() => t4.In.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.In.performConsistencyCheck(t3)).next(() => n.Qn.bn(t3, s));
  });
}
function lr(t2) {
  const e = U2(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.ze.getLastRemoteSnapshotVersion(t3));
}
function fr(t2, e) {
  const n = U2(t2), s = e.snapshotVersion;
  let i = n.Un;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.jn.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Un;
    const o = [];
    e.targetChanges.forEach((e2, r2) => {
      const a2 = i.get(r2);
      if (!a2)
        return;
      o.push(n.ze.removeMatchingKeys(t3, e2.removedDocuments, r2).next(() => n.ze.addMatchingKeys(t3, e2.addedDocuments, r2)));
      const c = e2.resumeToken;
      if (c.approximateByteSize() > 0) {
        const u = a2.withResumeToken(c, s).withSequenceNumber(t3.currentSequenceNumber);
        i = i.insert(r2, u), function(t4, e3, n2) {
          if (L2(e3.resumeToken.approximateByteSize() > 0), t4.resumeToken.approximateByteSize() === 0)
            return true;
          if (e3.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
            return true;
          return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
        }(a2, u, e2) && o.push(n.ze.updateTargetData(t3, u));
      }
    });
    let a = pn();
    if (e.documentUpdates.forEach((s2, i2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(dr(t3, r, e.documentUpdates, s, void 0).next((t4) => {
      a = t4;
    })), !s.isEqual(it.min())) {
      const e2 = n.ze.getLastRemoteSnapshotVersion(t3).next((e3) => n.ze.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return Ks.waitFor(o).next(() => r.apply(t3)).next(() => n.Qn.vn(t3, a)).next(() => a);
  }).then((t3) => (n.Un = i, t3));
}
function dr(t2, e, n, s, i) {
  let r = Pn();
  return n.forEach((t3) => r = r.add(t3)), e.getEntries(t2, r).next((t3) => {
    let r2 = pn();
    return n.forEach((n2, o) => {
      const a = t3.get(n2), c = (i == null ? void 0 : i.get(n2)) || s;
      o.isNoDocument() && o.version.isEqual(it.min()) ? (e.removeEntry(n2, c), r2 = r2.insert(n2, o)) : !a.isValidDocument() || o.version.compareTo(a.version) > 0 || o.version.compareTo(a.version) === 0 && a.hasPendingWrites ? (e.addEntry(o, c), r2 = r2.insert(n2, o)) : k2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", a.version, " Watch version:", o.version);
    }), r2;
  });
}
function wr(t2, e) {
  const n = U2(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (e === void 0 && (e = -1), n.In.getNextMutationBatchAfterBatchId(t3, e)));
}
function _r(t2, e) {
  const n = U2(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.ze.getTargetData(t3, e).next((i) => i ? (s = i, Ks.resolve(s)) : n.ze.allocateTargetId(t3).next((i2) => (s = new si(e, i2, 0, t3.currentSequenceNumber), n.ze.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.Un.get(t3.targetId);
    return (s === null || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Un = n.Un.insert(t3.targetId, t3), n.qn.set(e, t3.targetId)), t3;
  });
}
async function mr(t2, e, n) {
  const s = U2(t2), i = s.Un.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!zs(t3))
      throw t3;
    k2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.Un = s.Un.remove(e), s.qn.delete(i.target);
}
function gr(t2, e, n) {
  const s = U2(t2);
  let i = it.min(), r = Pn();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = U2(t4), i2 = s2.qn.get(n2);
    return i2 !== void 0 ? Ks.resolve(s2.Un.get(i2)) : s2.ze.getTargetData(e2, n2);
  }(s, t3, Ee(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.ze.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Bn.getDocumentsMatchingQuery(t3, e, n ? i : it.min(), n ? r : Pn())).next((t4) => ({
    documents: t4,
    Gn: r
  })));
}
function yr(t2, e) {
  const n = U2(t2), s = U2(n.ze), i = n.Un.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.Et(t3, e).next((t4) => t4 ? t4.target : null));
}
function pr(t2) {
  const e = U2(t2);
  return e.persistence.runTransaction("Get new document changes", "readonly", (t3) => function(t4, e2, n) {
    const s = U2(t4);
    let i = pn(), r = ai(n);
    const o = zi(e2), a = IDBKeyRange.lowerBound(r, true);
    return o.Kt({
      index: Cs.readTimeIndex,
      range: a
    }, (t5, e3) => {
      const n2 = ri(s.N, e3);
      i = i.insert(n2.key, n2), r = e3.readTime;
    }).next(() => ({
      Tn: i,
      readTime: ci(r)
    }));
  }(e.jn, t3, e.Kn)).then(({ Tn: t3, readTime: n }) => (e.Kn = n, t3));
}
async function Er(t2) {
  const e = U2(t2);
  return e.persistence.runTransaction("Synchronize last document change read time", "readonly", (t3) => function(t4) {
    const e2 = zi(t4);
    let n = it.min();
    return e2.Kt({
      index: Cs.readTimeIndex,
      reverse: true
    }, (t5, e3, s) => {
      e3.readTime && (n = ci(e3.readTime)), s.done();
    }).next(() => n);
  }(t3)).then((t3) => {
    e.Kn = t3;
  });
}
async function Tr(t2, e, n, s) {
  const i = U2(t2);
  let r = Pn(), o = pn(), a = An();
  for (const t3 of n) {
    const n2 = e.zn(t3.metadata.name);
    t3.document && (r = r.add(n2)), o = o.insert(n2, e.Hn(t3)), a = a.insert(n2, e.Jn(t3.metadata.readTime));
  }
  const c = i.jn.newChangeBuffer({
    trackRemovals: true
  }), u = await _r(i, function(t3) {
    return Ee(de(ut.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => dr(t3, c, o, it.min(), a).next((e2) => (c.apply(t3), e2)).next((e2) => i.ze.removeMatchingKeysForTargetId(t3, u.targetId).next(() => i.ze.addMatchingKeys(t3, r, u.targetId)).next(() => i.Qn.vn(t3, e2)).next(() => e2)));
}
async function Ir(t2, e, n = Pn()) {
  const s = await _r(t2, Ee(wi(e.bundledQuery))), i = U2(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = Kn(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.Je.saveNamedQuery(t3, e);
    const o = s.withResumeToken(wt.EMPTY_BYTE_STRING, r);
    return i.Un = i.Un.insert(o.targetId, o), i.ze.updateTargetData(t3, o).next(() => i.ze.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.ze.addMatchingKeys(t3, n, s.targetId)).next(() => i.Je.saveNamedQuery(t3, e));
  });
}
var Ar = class {
  constructor(t2) {
    this.N = t2, this.Yn = new Map(), this.Xn = new Map();
  }
  getBundleMetadata(t2, e) {
    return Ks.resolve(this.Yn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Yn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: Kn(n.createTime)
    }), Ks.resolve();
  }
  getNamedQuery(t2, e) {
    return Ks.resolve(this.Xn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Xn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: wi(t3.bundledQuery),
        readTime: Kn(t3.readTime)
      };
    }(e)), Ks.resolve();
  }
};
var Rr = class {
  constructor() {
    this.Zn = new mn(Pr.ts), this.es = new mn(Pr.ns);
  }
  isEmpty() {
    return this.Zn.isEmpty();
  }
  addReference(t2, e) {
    const n = new Pr(t2, e);
    this.Zn = this.Zn.add(n), this.es = this.es.add(n);
  }
  ss(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.rs(new Pr(t2, e));
  }
  os(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  cs(t2) {
    const e = new Pt(new ut([])), n = new Pr(e, t2), s = new Pr(e, t2 + 1), i = [];
    return this.es.forEachInRange([n, s], (t3) => {
      this.rs(t3), i.push(t3.key);
    }), i;
  }
  us() {
    this.Zn.forEach((t2) => this.rs(t2));
  }
  rs(t2) {
    this.Zn = this.Zn.delete(t2), this.es = this.es.delete(t2);
  }
  hs(t2) {
    const e = new Pt(new ut([])), n = new Pr(e, t2), s = new Pr(e, t2 + 1);
    let i = Pn();
    return this.es.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new Pr(t2, 0), n = this.Zn.firstAfterOrEqual(e);
    return n !== null && t2.isEqual(n.key);
  }
};
var Pr = class {
  constructor(t2, e) {
    this.key = t2, this.ls = e;
  }
  static ts(t2, e) {
    return Pt.comparator(t2.key, e.key) || tt(t2.ls, e.ls);
  }
  static ns(t2, e) {
    return tt(t2.ls, e.ls) || Pt.comparator(t2.key, e.key);
  }
};
var br = class {
  constructor(t2, e) {
    this.Ht = t2, this.referenceDelegate = e, this.In = [], this.fs = 1, this.ds = new mn(Pr.ts);
  }
  checkEmpty(t2) {
    return Ks.resolve(this.In.length === 0);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.fs;
    this.fs++, this.In.length > 0 && this.In[this.In.length - 1];
    const r = new ei(i, e, n, s);
    this.In.push(r);
    for (const e2 of s)
      this.ds = this.ds.add(new Pr(e2.key, i)), this.Ht.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return Ks.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return Ks.resolve(this.ws(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this._s(n), i = s < 0 ? 0 : s;
    return Ks.resolve(this.In.length > i ? this.In[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return Ks.resolve(this.In.length === 0 ? -1 : this.fs - 1);
  }
  getAllMutationBatches(t2) {
    return Ks.resolve(this.In.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new Pr(e, 0), s = new Pr(e, Number.POSITIVE_INFINITY), i = [];
    return this.ds.forEachInRange([n, s], (t3) => {
      const e2 = this.ws(t3.ls);
      i.push(e2);
    }), Ks.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new mn(tt);
    return e.forEach((t3) => {
      const e2 = new Pr(t3, 0), s = new Pr(t3, Number.POSITIVE_INFINITY);
      this.ds.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.ls);
      });
    }), Ks.resolve(this.gs(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    Pt.isDocumentKey(i) || (i = i.child(""));
    const r = new Pr(new Pt(i), 0);
    let o = new mn(tt);
    return this.ds.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ls)), true);
    }, r), Ks.resolve(this.gs(o));
  }
  gs(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.ws(t3);
      n !== null && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    L2(this.ys(e.batchId, "removed") === 0), this.In.shift();
    let n = this.ds;
    return Ks.forEach(e.mutations, (s) => {
      const i = new Pr(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this.ds = n;
    });
  }
  te(t2) {
  }
  containsKey(t2, e) {
    const n = new Pr(e, 0), s = this.ds.firstAfterOrEqual(n);
    return Ks.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.In.length, Ks.resolve();
  }
  ys(t2, e) {
    return this._s(t2);
  }
  _s(t2) {
    if (this.In.length === 0)
      return 0;
    return t2 - this.In[0].batchId;
  }
  ws(t2) {
    const e = this._s(t2);
    if (e < 0 || e >= this.In.length)
      return null;
    return this.In[e];
  }
};
var vr = class {
  constructor(t2, e) {
    this.Ht = t2, this.ps = e, this.docs = new dn(Pt.comparator), this.size = 0;
  }
  addEntry(t2, e, n) {
    const s = e.key, i = this.docs.get(s), r = i ? i.size : 0, o = this.ps(e);
    return this.docs = this.docs.insert(s, {
      document: e.clone(),
      size: o,
      readTime: n
    }), this.size += o - r, this.Ht.addToCollectionParentIndex(t2, s.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return Ks.resolve(n ? n.document.clone() : qt.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = pn();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.clone() : qt.newInvalidDocument(t3));
    }), Ks.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n) {
    let s = pn();
    const i = new Pt(e.path.child("")), r = this.docs.getIteratorFrom(i);
    for (; r.hasNext(); ) {
      const { key: t3, value: { document: i2, readTime: o } } = r.getNext();
      if (!e.path.isPrefixOf(t3.path))
        break;
      o.compareTo(n) <= 0 || Pe(e, i2) && (s = s.insert(i2.key, i2.clone()));
    }
    return Ks.resolve(s);
  }
  Es(t2, e) {
    return Ks.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new Vr(this);
  }
  getSize(t2) {
    return Ks.resolve(this.size);
  }
};
var Vr = class extends ji {
  constructor(t2) {
    super(), this.Se = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.document.isValidDocument() ? e.push(this.Se.addEntry(t2, s.document, this.getReadTime(n))) : this.Se.removeEntry(n);
    }), Ks.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Se.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Se.getEntries(t2, e);
  }
};
var Sr = class {
  constructor(t2) {
    this.persistence = t2, this.Ts = new Ki((t3) => Qt(t3), Gt), this.lastRemoteSnapshotVersion = it.min(), this.highestTargetId = 0, this.Is = 0, this.As = new Rr(), this.targetCount = 0, this.Rs = Ci.se();
  }
  forEachTarget(t2, e) {
    return this.Ts.forEach((t3, n) => e(n)), Ks.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return Ks.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return Ks.resolve(this.Is);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.Rs.next(), Ks.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Is && (this.Is = e), Ks.resolve();
  }
  ae(t2) {
    this.Ts.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.Rs = new Ci(e), this.highestTargetId = e), t2.sequenceNumber > this.Is && (this.Is = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.ae(e), this.targetCount += 1, Ks.resolve();
  }
  updateTargetData(t2, e) {
    return this.ae(e), Ks.resolve();
  }
  removeTargetData(t2, e) {
    return this.Ts.delete(e.target), this.As.cs(e.targetId), this.targetCount -= 1, Ks.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.Ts.forEach((r, o) => {
      o.sequenceNumber <= e && n.get(o.targetId) === null && (this.Ts.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), Ks.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return Ks.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.Ts.get(e) || null;
    return Ks.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.As.ss(e, n), Ks.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.As.os(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), Ks.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.As.cs(e), Ks.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.As.hs(e);
    return Ks.resolve(n);
  }
  containsKey(t2, e) {
    return Ks.resolve(this.As.containsKey(e));
  }
};
var Dr = class {
  constructor(t2, e) {
    this.Ps = {}, this.Le = new Y2(0), this.Be = false, this.Be = true, this.referenceDelegate = t2(this), this.ze = new Sr(this);
    this.Ht = new yi(), this.He = function(t3, e2) {
      return new vr(t3, e2);
    }(this.Ht, (t3) => this.referenceDelegate.bs(t3)), this.N = new ii(e), this.Je = new Ar(this.N);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Be = false, Promise.resolve();
  }
  get started() {
    return this.Be;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager() {
    return this.Ht;
  }
  getMutationQueue(t2) {
    let e = this.Ps[t2.toKey()];
    return e || (e = new br(this.Ht, this.referenceDelegate), this.Ps[t2.toKey()] = e), e;
  }
  getTargetCache() {
    return this.ze;
  }
  getRemoteDocumentCache() {
    return this.He;
  }
  getBundleCache() {
    return this.Je;
  }
  runTransaction(t2, e, n) {
    k2("MemoryPersistence", "Starting transaction:", t2);
    const s = new Cr(this.Le.next());
    return this.referenceDelegate.vs(), n(s).next((t3) => this.referenceDelegate.Vs(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Ss(t2, e) {
    return Ks.or(Object.values(this.Ps).map((n) => () => n.containsKey(t2, e)));
  }
};
var Cr = class extends qs {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var Nr = class {
  constructor(t2) {
    this.persistence = t2, this.Ds = new Rr(), this.Cs = null;
  }
  static Ns(t2) {
    return new Nr(t2);
  }
  get xs() {
    if (this.Cs)
      return this.Cs;
    throw M2();
  }
  addReference(t2, e, n) {
    return this.Ds.addReference(n, e), this.xs.delete(n.toString()), Ks.resolve();
  }
  removeReference(t2, e, n) {
    return this.Ds.removeReference(n, e), this.xs.add(n.toString()), Ks.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.xs.add(e.toString()), Ks.resolve();
  }
  removeTarget(t2, e) {
    this.Ds.cs(e.targetId).forEach((t3) => this.xs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.xs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  vs() {
    this.Cs = new Set();
  }
  Vs(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return Ks.forEach(this.xs, (n) => {
      const s = Pt.fromPath(n);
      return this.ks(t2, s).next((t3) => {
        t3 || e.removeEntry(s);
      });
    }).next(() => (this.Cs = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.ks(t2, e).next((t3) => {
      t3 ? this.xs.delete(e.toString()) : this.xs.add(e.toString());
    });
  }
  bs(t2) {
    return 0;
  }
  ks(t2, e) {
    return Ks.or([() => Ks.resolve(this.Ds.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Ss(t2, e)]);
  }
};
function xr(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function kr(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function $r(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var Or = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static $s(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = typeof s == "object" && ["pending", "acknowledged", "rejected"].indexOf(s.state) !== -1 && (s.error === void 0 || typeof s.error == "object");
    return r && s.error && (r = typeof s.error.message == "string" && typeof s.error.code == "string", r && (i = new K2(s.error.code, s.error.message))), r ? new Or(t2, e, s.state, i) : ($("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Fr = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static $s(t2, e) {
    const n = JSON.parse(e);
    let s, i = typeof n == "object" && ["not-current", "current", "rejected"].indexOf(n.state) !== -1 && (n.error === void 0 || typeof n.error == "object");
    return i && n.error && (i = typeof n.error.message == "string" && typeof n.error.code == "string", i && (s = new K2(n.error.code, n.error.message))), i ? new Fr(t2, n.state, s) : ($("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Os() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var Mr = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static $s(t2, e) {
    const n = JSON.parse(e);
    let s = typeof n == "object" && n.activeTargetIds instanceof Array, i = vn();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Rt(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new Mr(t2, i) : ($("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var Lr = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static $s(t2) {
    const e = JSON.parse(t2);
    return typeof e == "object" && ["Unknown", "Online", "Offline"].indexOf(e.onlineState) !== -1 && typeof e.clientId == "string" ? new Lr(e.clientId, e.onlineState) : ($("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var Br = class {
  constructor() {
    this.activeTargetIds = vn();
  }
  Fs(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  Ms(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Os() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var Ur = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Oe = e, this.persistenceKey = n, this.Ls = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.Bs = this.Us.bind(this), this.qs = new dn(tt), this.started = false, this.Ks = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.js = xr(this.persistenceKey, this.Ls), this.Qs = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.qs = this.qs.insert(this.Ls, new Br()), this.Ws = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.Gs = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.zs = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.Hs = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this.Js = function(t3) {
      return `firestore_bundle_loaded_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.Bs);
  }
  static Pt(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.pn();
    for (const e2 of t2) {
      if (e2 === this.Ls)
        continue;
      const t3 = this.getItem(xr(this.persistenceKey, e2));
      if (t3) {
        const n = Mr.$s(e2, t3);
        n && (this.qs = this.qs.insert(n.clientId, n));
      }
    }
    this.Ys();
    const e = this.storage.getItem(this.Hs);
    if (e) {
      const t3 = this.Xs(e);
      t3 && this.Zs(t3);
    }
    for (const t3 of this.Ks)
      this.Us(t3);
    this.Ks = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.Qs, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.ti(this.qs);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.qs.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.ei(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.ei(t2, e, n), this.ni(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem($r(this.persistenceKey, t2));
      if (n) {
        const s = Fr.$s(t2, n);
        s && (e = s.state);
      }
    }
    return this.si.Fs(t2), this.Ys(), e;
  }
  removeLocalQueryTarget(t2) {
    this.si.Ms(t2), this.Ys();
  }
  isLocalQueryTarget(t2) {
    return this.si.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem($r(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.ii(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.ni(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.ri(t2);
  }
  notifyBundleLoaded() {
    this.oi();
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.Bs), this.removeItem(this.js), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return k2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    k2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    k2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  Us(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (k2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.js)
        return void $("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Oe.enqueueRetryable(async () => {
        if (this.started) {
          if (e.key !== null) {
            if (this.Ws.test(e.key)) {
              if (e.newValue == null) {
                const t3 = this.ai(e.key);
                return this.ci(t3, null);
              }
              {
                const t3 = this.ui(e.key, e.newValue);
                if (t3)
                  return this.ci(t3.clientId, t3);
              }
            } else if (this.Gs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.hi(e.key, e.newValue);
                if (t3)
                  return this.li(t3);
              }
            } else if (this.zs.test(e.key)) {
              if (e.newValue !== null) {
                const t3 = this.fi(e.key, e.newValue);
                if (t3)
                  return this.di(t3);
              }
            } else if (e.key === this.Hs) {
              if (e.newValue !== null) {
                const t3 = this.Xs(e.newValue);
                if (t3)
                  return this.Zs(t3);
              }
            } else if (e.key === this.Qs) {
              const t3 = function(t4) {
                let e2 = Y2.T;
                if (t4 != null)
                  try {
                    const n = JSON.parse(t4);
                    L2(typeof n == "number"), e2 = n;
                  } catch (t5) {
                    $("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== Y2.T && this.sequenceNumberHandler(t3);
            } else if (e.key === this.Js)
              return this.syncEngine.wi();
          }
        } else
          this.Ks.push(e);
      });
    }
  }
  get si() {
    return this.qs.get(this.Ls);
  }
  Ys() {
    this.setItem(this.js, this.si.Os());
  }
  ei(t2, e, n) {
    const s = new Or(this.currentUser, t2, e, n), i = kr(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Os());
  }
  ni(t2) {
    const e = kr(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  ri(t2) {
    const e = {
      clientId: this.Ls,
      onlineState: t2
    };
    this.storage.setItem(this.Hs, JSON.stringify(e));
  }
  ii(t2, e, n) {
    const s = $r(this.persistenceKey, t2), i = new Fr(t2, e, n);
    this.setItem(s, i.Os());
  }
  oi() {
    this.setItem(this.Js, "value-not-used");
  }
  ai(t2) {
    const e = this.Ws.exec(t2);
    return e ? e[1] : null;
  }
  ui(t2, e) {
    const n = this.ai(t2);
    return Mr.$s(n, e);
  }
  hi(t2, e) {
    const n = this.Gs.exec(t2), s = Number(n[1]), i = n[2] !== void 0 ? n[2] : null;
    return Or.$s(new S2(i), s, e);
  }
  fi(t2, e) {
    const n = this.zs.exec(t2), s = Number(n[1]);
    return Fr.$s(s, e);
  }
  Xs(t2) {
    return Lr.$s(t2);
  }
  async li(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine._i(t2.batchId, t2.state, t2.error);
    k2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  di(t2) {
    return this.syncEngine.mi(t2.targetId, t2.state, t2.error);
  }
  ci(t2, e) {
    const n = e ? this.qs.insert(t2, e) : this.qs.remove(t2), s = this.ti(this.qs), i = this.ti(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.gi(r, o).then(() => {
      this.qs = n;
    });
  }
  Zs(t2) {
    this.qs.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  ti(t2) {
    let e = vn();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var qr = class {
  constructor() {
    this.yi = new Br(), this.pi = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.yi.Fs(t2), this.pi[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.pi[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.yi.Ms(t2);
  }
  isLocalQueryTarget(t2) {
    return this.yi.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.pi[t2];
  }
  getAllActiveQueryTargets() {
    return this.yi.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.yi.activeTargetIds.has(t2);
  }
  start() {
    return this.yi = new Br(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded() {
  }
};
var Kr = class {
  Ei(t2) {
  }
  shutdown() {
  }
};
var jr = class {
  constructor() {
    this.Ti = () => this.Ii(), this.Ai = () => this.Ri(), this.Pi = [], this.bi();
  }
  Ei(t2) {
    this.Pi.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ti), window.removeEventListener("offline", this.Ai);
  }
  bi() {
    window.addEventListener("online", this.Ti), window.addEventListener("offline", this.Ai);
  }
  Ii() {
    k2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.Pi)
      t2(0);
  }
  Ri() {
    k2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.Pi)
      t2(1);
  }
  static Pt() {
    return typeof window != "undefined" && window.addEventListener !== void 0 && window.removeEventListener !== void 0;
  }
};
var Qr = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery"
};
var Wr = class {
  constructor(t2) {
    this.vi = t2.vi, this.Vi = t2.Vi;
  }
  Si(t2) {
    this.Di = t2;
  }
  Ci(t2) {
    this.Ni = t2;
  }
  onMessage(t2) {
    this.xi = t2;
  }
  close() {
    this.Vi();
  }
  send(t2) {
    this.vi(t2);
  }
  ki() {
    this.Di();
  }
  $i(t2) {
    this.Ni(t2);
  }
  Oi(t2) {
    this.xi(t2);
  }
};
var Gr = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.Fi = e + "://" + t2.host, this.Mi = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  Li(t2, e, n, s) {
    const i = this.Bi(t2, e);
    k2("RestConnection", "Sending: ", i, n);
    const r = {};
    return this.Ui(r, s), this.qi(t2, i, r, n).then((t3) => (k2("RestConnection", "Received: ", t3), t3), (e2) => {
      throw O2("RestConnection", `${t2} failed with error: `, e2, "url: ", i, "request:", n), e2;
    });
  }
  Ki(t2, e, n, s) {
    return this.Li(t2, e, n, s);
  }
  Ui(t2, e) {
    if (t2["X-Goog-Api-Client"] = "gl-js/ fire/" + D2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e)
      for (const n in e.authHeaders)
        e.authHeaders.hasOwnProperty(n) && (t2[n] = e.authHeaders[n]);
  }
  Bi(t2, e) {
    const n = Qr[t2];
    return `${this.Fi}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  qi(t2, e, n, s) {
    return new Promise((i, r) => {
      const o = new XhrIo();
      o.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (o.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = o.getResponseJson();
              k2("Connection", "XHR received:", JSON.stringify(e2)), i(e2);
              break;
            case ErrorCode.TIMEOUT:
              k2("Connection", 'RPC "' + t2 + '" timed out'), r(new K2(q2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = o.getStatus();
              if (k2("Connection", 'RPC "' + t2 + '" failed with status:', n2, "response text:", o.getResponseText()), n2 > 0) {
                const t3 = o.getResponseJson().error;
                if (t3 && t3.status && t3.message) {
                  const e3 = function(t4) {
                    const e4 = t4.toLowerCase().replace(/_/g, "-");
                    return Object.values(q2).indexOf(e4) >= 0 ? e4 : q2.UNKNOWN;
                  }(t3.status);
                  r(new K2(e3, t3.message));
                } else
                  r(new K2(q2.UNKNOWN, "Server responded with status " + o.getStatus()));
              } else
                r(new K2(q2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              M2();
          }
        } finally {
          k2("Connection", 'RPC "' + t2 + '" completed.');
        }
      });
      const a = JSON.stringify(s);
      o.send(e, "POST", a, n, 15);
    });
  }
  ji(t2, e) {
    const n = [this.Fi, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], s = createWebChannelTransport(), i = getStatEventTarget(), r = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (r.xmlHttpFactory = new FetchXmlHttpFactory({})), this.Ui(r.initMessageHeaders, e), isMobileCordova() || isReactNative() || isElectron() || isIE() || isUWP() || isBrowserExtension() || (r.httpHeadersOverwriteParam = "$httpHeaders");
    const o = n.join("");
    k2("Connection", "Creating WebChannel: " + o, r);
    const a = s.createWebChannel(o, r);
    let c = false, u = false;
    const h = new Wr({
      vi: (t3) => {
        u ? k2("Connection", "Not sending because WebChannel is closed:", t3) : (c || (k2("Connection", "Opening WebChannel transport."), a.open(), c = true), k2("Connection", "WebChannel sending:", t3), a.send(t3));
      },
      Vi: () => a.close()
    }), g = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return g(a, WebChannel.EventType.OPEN, () => {
      u || k2("Connection", "WebChannel transport opened.");
    }), g(a, WebChannel.EventType.CLOSE, () => {
      u || (u = true, k2("Connection", "WebChannel transport closed"), h.$i());
    }), g(a, WebChannel.EventType.ERROR, (t3) => {
      u || (u = true, O2("Connection", "WebChannel transport errored:", t3), h.$i(new K2(q2.UNAVAILABLE, "The operation could not be completed")));
    }), g(a, WebChannel.EventType.MESSAGE, (t3) => {
      var e2;
      if (!u) {
        const n2 = t3.data[0];
        L2(!!n2);
        const s2 = n2, i2 = s2.error || ((e2 = s2[0]) === null || e2 === void 0 ? void 0 : e2.error);
        if (i2) {
          k2("Connection", "WebChannel received error:", i2);
          const t4 = i2.status;
          let e3 = function(t5) {
            const e4 = un[t5];
            if (e4 !== void 0)
              return fn(e4);
          }(t4), n3 = i2.message;
          e3 === void 0 && (e3 = q2.INTERNAL, n3 = "Unknown error status: " + t4 + " with message " + i2.message), u = true, h.$i(new K2(e3, n3)), a.close();
        } else
          k2("Connection", "WebChannel received:", n2), h.Oi(n2);
      }
    }), g(i, Event.STAT_EVENT, (t3) => {
      t3.stat === Stat.PROXY ? k2("Connection", "Detected buffering proxy") : t3.stat === Stat.NOPROXY && k2("Connection", "Detected no buffering proxy");
    }), setTimeout(() => {
      h.ki();
    }, 0), h;
  }
};
function zr() {
  return typeof window != "undefined" ? window : null;
}
function Hr() {
  return typeof document != "undefined" ? document : null;
}
function Jr(t2) {
  return new Ln(t2, true);
}
var Yr = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Oe = t2, this.timerId = e, this.Qi = n, this.Wi = s, this.Gi = i, this.zi = 0, this.Hi = null, this.Ji = Date.now(), this.reset();
  }
  reset() {
    this.zi = 0;
  }
  Yi() {
    this.zi = this.Gi;
  }
  Xi(t2) {
    this.cancel();
    const e = Math.floor(this.zi + this.Zi()), n = Math.max(0, Date.now() - this.Ji), s = Math.max(0, e - n);
    s > 0 && k2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.zi} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Hi = this.Oe.enqueueAfterDelay(this.timerId, s, () => (this.Ji = Date.now(), t2())), this.zi *= this.Wi, this.zi < this.Qi && (this.zi = this.Qi), this.zi > this.Gi && (this.zi = this.Gi);
  }
  tr() {
    this.Hi !== null && (this.Hi.skipDelay(), this.Hi = null);
  }
  cancel() {
    this.Hi !== null && (this.Hi.cancel(), this.Hi = null);
  }
  Zi() {
    return (Math.random() - 0.5) * this.zi;
  }
};
var Xr = class {
  constructor(t2, e, n, s, i, r) {
    this.Oe = t2, this.er = n, this.nr = s, this.credentialsProvider = i, this.listener = r, this.state = 0, this.sr = 0, this.ir = null, this.stream = null, this.rr = new Yr(t2, e);
  }
  ar() {
    return this.state === 1 || this.state === 2 || this.state === 4;
  }
  cr() {
    return this.state === 2;
  }
  start() {
    this.state !== 3 ? this.auth() : this.ur();
  }
  async stop() {
    this.ar() && await this.close(0);
  }
  hr() {
    this.state = 0, this.rr.reset();
  }
  lr() {
    this.cr() && this.ir === null && (this.ir = this.Oe.enqueueAfterDelay(this.er, 6e4, () => this.dr()));
  }
  wr(t2) {
    this._r(), this.stream.send(t2);
  }
  async dr() {
    if (this.cr())
      return this.close(0);
  }
  _r() {
    this.ir && (this.ir.cancel(), this.ir = null);
  }
  async close(t2, e) {
    this._r(), this.rr.cancel(), this.sr++, t2 !== 3 ? this.rr.reset() : e && e.code === q2.RESOURCE_EXHAUSTED ? ($(e.toString()), $("Using maximum backoff delay to prevent overloading the backend."), this.rr.Yi()) : e && e.code === q2.UNAUTHENTICATED && this.credentialsProvider.invalidateToken(), this.stream !== null && (this.mr(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Ci(e);
  }
  mr() {
  }
  auth() {
    this.state = 1;
    const t2 = this.gr(this.sr), e = this.sr;
    this.credentialsProvider.getToken().then((t3) => {
      this.sr === e && this.yr(t3);
    }, (e2) => {
      t2(() => {
        const t3 = new K2(q2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.pr(t3);
      });
    });
  }
  yr(t2) {
    const e = this.gr(this.sr);
    this.stream = this.Er(t2), this.stream.Si(() => {
      e(() => (this.state = 2, this.listener.Si()));
    }), this.stream.Ci((t3) => {
      e(() => this.pr(t3));
    }), this.stream.onMessage((t3) => {
      e(() => this.onMessage(t3));
    });
  }
  ur() {
    this.state = 4, this.rr.Xi(async () => {
      this.state = 0, this.start();
    });
  }
  pr(t2) {
    return k2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(3, t2);
  }
  gr(t2) {
    return (e) => {
      this.Oe.enqueueAndForget(() => this.sr === t2 ? e() : (k2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var Zr = class extends Xr {
  constructor(t2, e, n, s, i) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", e, n, i), this.N = s;
  }
  Er(t2) {
    return this.nr.ji("Listen", t2);
  }
  onMessage(t2) {
    this.rr.reset();
    const e = es(this.N, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return it.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? it.min() : e2.readTime ? Kn(e2.readTime) : it.min();
    }(t2);
    return this.listener.Tr(e, n);
  }
  Ir(t2) {
    const e = {};
    e.database = Jn(this.N), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = zt(s) ? {
        documents: rs(t3, s)
      } : {
        query: os(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Un(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(it.min()) > 0 && (n2.readTime = Bn(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.N, t2);
    const n = cs(this.N, t2);
    n && (e.labels = n), this.wr(e);
  }
  Ar(t2) {
    const e = {};
    e.database = Jn(this.N), e.removeTarget = t2, this.wr(e);
  }
};
var to = class extends Xr {
  constructor(t2, e, n, s, i) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", e, n, i), this.N = s, this.Rr = false;
  }
  get Pr() {
    return this.Rr;
  }
  start() {
    this.Rr = false, this.lastStreamToken = void 0, super.start();
  }
  mr() {
    this.Rr && this.br([]);
  }
  Er(t2) {
    return this.nr.ji("Write", t2);
  }
  onMessage(t2) {
    if (L2(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Rr) {
      this.rr.reset();
      const e = is(t2.writeResults, t2.commitTime), n = Kn(t2.commitTime);
      return this.listener.vr(n, e);
    }
    return L2(!t2.writeResults || t2.writeResults.length === 0), this.Rr = true, this.listener.Vr();
  }
  Sr() {
    const t2 = {};
    t2.database = Jn(this.N), this.wr(t2);
  }
  br(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => ns(this.N, t3))
    };
    this.wr(e);
  }
};
var eo = class extends class {
} {
  constructor(t2, e, n) {
    super(), this.credentials = t2, this.nr = e, this.N = n, this.Dr = false;
  }
  Cr() {
    if (this.Dr)
      throw new K2(q2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  Li(t2, e, n) {
    return this.Cr(), this.credentials.getToken().then((s) => this.nr.Li(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === q2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new K2(q2.UNKNOWN, t3.toString());
    });
  }
  Ki(t2, e, n) {
    return this.Cr(), this.credentials.getToken().then((s) => this.nr.Ki(t2, e, n, s)).catch((t3) => {
      throw t3.name === "FirebaseError" ? (t3.code === q2.UNAUTHENTICATED && this.credentials.invalidateToken(), t3) : new K2(q2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.Dr = true;
  }
};
var no = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.Nr = 0, this.kr = null, this.$r = true;
  }
  Or() {
    this.Nr === 0 && (this.Fr("Unknown"), this.kr = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.kr = null, this.Mr("Backend didn't respond within 10 seconds."), this.Fr("Offline"), Promise.resolve())));
  }
  Lr(t2) {
    this.state === "Online" ? this.Fr("Unknown") : (this.Nr++, this.Nr >= 1 && (this.Br(), this.Mr(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.Fr("Offline")));
  }
  set(t2) {
    this.Br(), this.Nr = 0, t2 === "Online" && (this.$r = false), this.Fr(t2);
  }
  Fr(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  Mr(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.$r ? ($(e), this.$r = false) : k2("OnlineStateTracker", e);
  }
  Br() {
    this.kr !== null && (this.kr.cancel(), this.kr = null);
  }
};
var so = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.Ur = [], this.qr = new Map(), this.Kr = new Set(), this.jr = [], this.Qr = i, this.Qr.Ei((t3) => {
      n.enqueueAndForget(async () => {
        fo(this) && (k2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = U2(t4);
          e2.Kr.add(4), await ro(e2), e2.Wr.set("Unknown"), e2.Kr.delete(4), await io(e2);
        }(this));
      });
    }), this.Wr = new no(n, s);
  }
};
async function io(t2) {
  if (fo(t2))
    for (const e of t2.jr)
      await e(true);
}
async function ro(t2) {
  for (const e of t2.jr)
    await e(false);
}
function oo(t2, e) {
  const n = U2(t2);
  n.qr.has(e.targetId) || (n.qr.set(e.targetId, e), lo(n) ? ho(n) : Do(n).cr() && co(n, e));
}
function ao(t2, e) {
  const n = U2(t2), s = Do(n);
  n.qr.delete(e), s.cr() && uo(n, e), n.qr.size === 0 && (s.cr() ? s.lr() : fo(n) && n.Wr.set("Unknown"));
}
function co(t2, e) {
  t2.Gr.Y(e.targetId), Do(t2).Ir(e);
}
function uo(t2, e) {
  t2.Gr.Y(e), Do(t2).Ar(e);
}
function ho(t2) {
  t2.Gr = new kn({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    Et: (e) => t2.qr.get(e) || null
  }), Do(t2).start(), t2.Wr.Or();
}
function lo(t2) {
  return fo(t2) && !Do(t2).ar() && t2.qr.size > 0;
}
function fo(t2) {
  return U2(t2).Kr.size === 0;
}
function wo(t2) {
  t2.Gr = void 0;
}
async function _o(t2) {
  t2.qr.forEach((e, n) => {
    co(t2, e);
  });
}
async function mo(t2, e) {
  wo(t2), lo(t2) ? (t2.Wr.Lr(e), ho(t2)) : t2.Wr.set("Unknown");
}
async function go(t2, e, n) {
  if (t2.Wr.set("Online"), e instanceof Nn && e.state === 2 && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.qr.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.qr.delete(s), t3.Gr.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      k2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await yo(t2, n2);
    }
  else if (e instanceof Dn ? t2.Gr.rt(e) : e instanceof Cn ? t2.Gr.ft(e) : t2.Gr.ct(e), !n.isEqual(it.min()))
    try {
      const e2 = await lr(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.Gr._t(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.qr.get(s);
            i && t3.qr.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.qr.get(e4);
          if (!n3)
            return;
          t3.qr.set(e4, n3.withResumeToken(wt.EMPTY_BYTE_STRING, n3.snapshotVersion)), uo(t3, e4);
          const s = new si(n3.target, e4, 1, n3.sequenceNumber);
          co(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      k2("RemoteStore", "Failed to raise snapshot:", e2), await yo(t2, e2);
    }
}
async function yo(t2, e, n) {
  if (!zs(e))
    throw e;
  t2.Kr.add(1), await ro(t2), t2.Wr.set("Offline"), n || (n = () => lr(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    k2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.Kr.delete(1), await io(t2);
  });
}
function po(t2, e) {
  return e().catch((n) => yo(t2, n, e));
}
async function Eo(t2) {
  const e = U2(t2), n = Co(e);
  let s = e.Ur.length > 0 ? e.Ur[e.Ur.length - 1].batchId : -1;
  for (; To(e); )
    try {
      const t3 = await wr(e.localStore, s);
      if (t3 === null) {
        e.Ur.length === 0 && n.lr();
        break;
      }
      s = t3.batchId, Io(e, t3);
    } catch (t3) {
      await yo(e, t3);
    }
  Ao(e) && Ro(e);
}
function To(t2) {
  return fo(t2) && t2.Ur.length < 10;
}
function Io(t2, e) {
  t2.Ur.push(e);
  const n = Co(t2);
  n.cr() && n.Pr && n.br(e.mutations);
}
function Ao(t2) {
  return fo(t2) && !Co(t2).ar() && t2.Ur.length > 0;
}
function Ro(t2) {
  Co(t2).start();
}
async function Po(t2) {
  Co(t2).Sr();
}
async function bo(t2) {
  const e = Co(t2);
  for (const n of t2.Ur)
    e.br(n.mutations);
}
async function vo(t2, e, n) {
  const s = t2.Ur.shift(), i = ni.from(s, e, n);
  await po(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Eo(t2);
}
async function Vo(t2, e) {
  e && Co(t2).Pr && await async function(t3, e2) {
    if (n = e2.code, ln(n) && n !== q2.ABORTED) {
      const n2 = t3.Ur.shift();
      Co(t3).hr(), await po(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Eo(t3);
    }
    var n;
  }(t2, e), Ao(t2) && Ro(t2);
}
async function So(t2, e) {
  const n = U2(t2);
  e ? (n.Kr.delete(2), await io(n)) : e || (n.Kr.add(2), await ro(n), n.Wr.set("Unknown"));
}
function Do(t2) {
  return t2.zr || (t2.zr = function(t3, e, n) {
    const s = U2(t3);
    return s.Cr(), new Zr(e, s.nr, s.credentials, s.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: _o.bind(null, t2),
    Ci: mo.bind(null, t2),
    Tr: go.bind(null, t2)
  }), t2.jr.push(async (e) => {
    e ? (t2.zr.hr(), lo(t2) ? ho(t2) : t2.Wr.set("Unknown")) : (await t2.zr.stop(), wo(t2));
  })), t2.zr;
}
function Co(t2) {
  return t2.Hr || (t2.Hr = function(t3, e, n) {
    const s = U2(t3);
    return s.Cr(), new to(e, s.nr, s.credentials, s.N, n);
  }(t2.datastore, t2.asyncQueue, {
    Si: Po.bind(null, t2),
    Ci: Vo.bind(null, t2),
    Vr: bo.bind(null, t2),
    vr: vo.bind(null, t2)
  }), t2.jr.push(async (e) => {
    e ? (t2.Hr.hr(), await Eo(t2)) : (await t2.Hr.stop(), t2.Ur.length > 0 && (k2("RemoteStore", `Stopping write stream with ${t2.Ur.length} pending writes`), t2.Ur = []));
  })), t2.Hr;
}
var No = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new j(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new No(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    this.timerHandle !== null && (this.clearTimeout(), this.deferred.reject(new K2(q2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => this.timerHandle !== null ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    this.timerHandle !== null && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function xo(t2, e) {
  if ($("AsyncQueue", `${e}: ${t2}`), zs(t2))
    return new K2(q2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var ko = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || Pt.comparator(e.key, n.key) : (t3, e) => Pt.comparator(t3.key, e.key), this.keyedMap = Tn(), this.sortedSet = new dn(this.comparator);
  }
  static emptySet(t2) {
    return new ko(t2.comparator);
  }
  has(t2) {
    return this.keyedMap.get(t2) != null;
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof ko))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), t2.length === 0 ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new ko();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var $o = class {
  constructor() {
    this.Jr = new dn(Pt.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.Jr.get(e);
    n ? t2.type !== 0 && n.type === 3 ? this.Jr = this.Jr.insert(e, t2) : t2.type === 3 && n.type !== 1 ? this.Jr = this.Jr.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 2 ? this.Jr = this.Jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : t2.type === 2 && n.type === 0 ? this.Jr = this.Jr.insert(e, {
      type: 0,
      doc: t2.doc
    }) : t2.type === 1 && n.type === 0 ? this.Jr = this.Jr.remove(e) : t2.type === 1 && n.type === 2 ? this.Jr = this.Jr.insert(e, {
      type: 1,
      doc: n.doc
    }) : t2.type === 0 && n.type === 1 ? this.Jr = this.Jr.insert(e, {
      type: 2,
      doc: t2.doc
    }) : M2() : this.Jr = this.Jr.insert(e, t2);
  }
  Yr() {
    const t2 = [];
    return this.Jr.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var Oo = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = a;
  }
  static fromInitialDocuments(t2, e, n, s) {
    const i = [];
    return e.forEach((t3) => {
      i.push({
        type: 0,
        doc: t3
      });
    }), new Oo(t2, e, ko.emptySet(e), i, n, s, true, false);
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Ie(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var Fo = class {
  constructor() {
    this.Xr = void 0, this.listeners = [];
  }
};
var Mo = class {
  constructor() {
    this.queries = new Ki((t2) => Ae(t2), Ie), this.onlineState = "Unknown", this.Zr = new Set();
  }
};
async function Lo(t2, e) {
  const n = U2(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new Fo()), i)
    try {
      r.Xr = await n.onListen(s);
    } catch (t3) {
      const n2 = xo(t3, `Initialization of query '${Re(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.eo(n.onlineState), r.Xr) {
    e.no(r.Xr) && Ko(n);
  }
}
async function Bo(t2, e) {
  const n = U2(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = r.listeners.length === 0);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Uo(t2, e) {
  const n = U2(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.no(t3) && (s = true);
      i.Xr = t3;
    }
  }
  s && Ko(n);
}
function qo(t2, e, n) {
  const s = U2(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Ko(t2) {
  t2.Zr.forEach((t3) => {
    t3.next();
  });
}
var jo = class {
  constructor(t2, e, n) {
    this.query = t2, this.so = e, this.io = false, this.ro = null, this.onlineState = "Unknown", this.options = n || {};
  }
  no(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        n.type !== 3 && e2.push(n);
      t2 = new Oo(t2.query, t2.docs, t2.oldDocs, e2, t2.mutatedKeys, t2.fromCache, t2.syncStateChanged, true);
    }
    let e = false;
    return this.io ? this.oo(t2) && (this.so.next(t2), e = true) : this.ao(t2, this.onlineState) && (this.co(t2), e = true), this.ro = t2, e;
  }
  onError(t2) {
    this.so.error(t2);
  }
  eo(t2) {
    this.onlineState = t2;
    let e = false;
    return this.ro && !this.io && this.ao(this.ro, t2) && (this.co(this.ro), e = true), e;
  }
  ao(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = e !== "Offline";
    return (!this.options.uo || !n) && (!t2.docs.isEmpty() || e === "Offline");
  }
  oo(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.ro && this.ro.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && this.options.includeMetadataChanges === true;
  }
  co(t2) {
    t2 = Oo.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache), this.io = true, this.so.next(t2);
  }
};
var Qo = class {
  constructor(t2, e) {
    this.payload = t2, this.byteLength = e;
  }
  ho() {
    return "metadata" in this.payload;
  }
};
var Wo = class {
  constructor(t2) {
    this.N = t2;
  }
  zn(t2) {
    return Gn(this.N, t2);
  }
  Hn(t2) {
    return t2.metadata.exists ? Zn(this.N, t2.document, false) : qt.newNoDocument(this.zn(t2.metadata.name), this.Jn(t2.metadata.readTime));
  }
  Jn(t2) {
    return Kn(t2);
  }
};
var Go = class {
  constructor(t2, e, n) {
    this.lo = t2, this.localStore = e, this.N = n, this.queries = [], this.documents = [], this.progress = zo(t2);
  }
  fo(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    return t2.payload.namedQuery ? this.queries.push(t2.payload.namedQuery) : t2.payload.documentMetadata ? (this.documents.push({
      metadata: t2.payload.documentMetadata
    }), t2.payload.documentMetadata.exists || ++e) : t2.payload.document && (this.documents[this.documents.length - 1].document = t2.payload.document, ++e), e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  wo(t2) {
    const e = new Map(), n = new Wo(this.N);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.zn(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || Pn()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await Tr(this.localStore, new Wo(this.N), this.documents, this.lo.id), e = this.wo(this.documents);
    for (const t3 of this.queries)
      await Ir(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", new sr(Object.assign({}, this.progress), t2);
  }
};
function zo(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Ho = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Jo = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Yo = class {
  constructor(t2, e) {
    this.query = t2, this._o = e, this.mo = null, this.current = false, this.yo = Pn(), this.mutatedKeys = Pn(), this.po = be(t2), this.Eo = new ko(this.po);
  }
  get To() {
    return this._o;
  }
  Io(t2, e) {
    const n = e ? e.Ao : new $o(), s = e ? e.Eo : this.Eo;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const a = we(this.query) && s.size === this.query.limit ? s.last() : null, c = _e(this.query) && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const u = s.get(t3), h = Pe(this.query, e2) ? e2 : null, l2 = !!u && this.mutatedKeys.has(u.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (u && h) {
        u.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Ro(u, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (a && this.po(h, a) > 0 || c && this.po(h, c) < 0) && (o = true));
      } else
        !u && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : u && !h && (n.track({
          type: 1,
          doc: u
        }), d = true, (a || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), we(this.query) || _e(this.query))
      for (; r.size > this.query.limit; ) {
        const t3 = we(this.query) ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Eo: r,
      Ao: n,
      Ln: o,
      mutatedKeys: i
    };
  }
  Ro(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Eo;
    this.Eo = t2.Eo, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.Ao.Yr();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return M2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.po(t3.doc, e2.doc)), this.Po(n);
    const r = e ? this.bo() : [], o = this.yo.size === 0 && this.current ? 1 : 0, a = o !== this.mo;
    if (this.mo = o, i.length !== 0 || a) {
      return {
        snapshot: new Oo(this.query, t2.Eo, s, i, t2.mutatedKeys, o === 0, a, false),
        vo: r
      };
    }
    return {
      vo: r
    };
  }
  eo(t2) {
    return this.current && t2 === "Offline" ? (this.current = false, this.applyChanges({
      Eo: this.Eo,
      Ao: new $o(),
      mutatedKeys: this.mutatedKeys,
      Ln: false
    }, false)) : {
      vo: []
    };
  }
  Vo(t2) {
    return !this._o.has(t2) && (!!this.Eo.has(t2) && !this.Eo.get(t2).hasLocalMutations);
  }
  Po(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this._o = this._o.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this._o = this._o.delete(t3)), this.current = t2.current);
  }
  bo() {
    if (!this.current)
      return [];
    const t2 = this.yo;
    this.yo = Pn(), this.Eo.forEach((t3) => {
      this.Vo(t3.key) && (this.yo = this.yo.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.yo.has(t3) || e.push(new Jo(t3));
    }), this.yo.forEach((n) => {
      t2.has(n) || e.push(new Ho(n));
    }), e;
  }
  So(t2) {
    this._o = t2.Gn, this.yo = Pn();
    const e = this.Io(t2.documents);
    return this.applyChanges(e, true);
  }
  Do() {
    return Oo.fromInitialDocuments(this.query, this.Eo, this.mutatedKeys, this.mo === 0);
  }
};
var Xo = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var Zo = class {
  constructor(t2) {
    this.key = t2, this.Co = false;
  }
};
var ta2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.No = {}, this.xo = new Ki((t3) => Ae(t3), Ie), this.ko = new Map(), this.$o = new Set(), this.Oo = new dn(Pt.comparator), this.Fo = new Map(), this.Mo = new Rr(), this.Lo = {}, this.Bo = new Map(), this.Uo = Ci.ie(), this.onlineState = "Unknown", this.qo = void 0;
  }
  get isPrimaryClient() {
    return this.qo === true;
  }
};
async function ea2(t2, e) {
  const n = Da(t2);
  let s, i;
  const r = n.xo.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.Do();
  else {
    const t3 = await _r(n.localStore, Ee(e)), r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await na2(n, e, s, r2 === "current"), n.isPrimaryClient && oo(n.remoteStore, t3);
  }
  return i;
}
async function na2(t2, e, n, s) {
  t2.Ko = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.Io(n3);
    i2.Ln && (i2 = await gr(t3.localStore, e3.query, false).then(({ documents: t4 }) => e3.view.Io(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(i2, t3.isPrimaryClient, r2);
    return _a(t3, e3.targetId, o2.vo), o2.snapshot;
  }(t2, e2, n2, s2);
  const i = await gr(t2.localStore, e, true), r = new Yo(e, i.Gn), o = r.Io(i.documents), a = Sn.createSynthesizedTargetChangeForCurrentChange(n, s && t2.onlineState !== "Offline"), c = r.applyChanges(o, t2.isPrimaryClient, a);
  _a(t2, n, c.vo);
  const u = new Xo(e, n, r);
  return t2.xo.set(e, u), t2.ko.has(n) ? t2.ko.get(n).push(e) : t2.ko.set(n, [e]), c.snapshot;
}
async function sa2(t2, e) {
  const n = U2(t2), s = n.xo.get(e), i = n.ko.get(s.targetId);
  if (i.length > 1)
    return n.ko.set(s.targetId, i.filter((t3) => !Ie(t3, e))), void n.xo.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await mr(n.localStore, s.targetId, false).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), ao(n.remoteStore, s.targetId), da2(n, s.targetId);
    }).catch(Oi);
  } else
    da2(n, s.targetId), await mr(n.localStore, s.targetId, true);
}
async function ia2(t2, e, n) {
  const s = Ca2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = U2(t4), s2 = st.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), Pn());
      let r;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => n2.Qn.bn(t5, i).next((i2) => {
        r = i2;
        const o = [];
        for (const t6 of e2) {
          const e3 = Ye(t6, r.get(t6.key));
          e3 != null && o.push(new en(t6.key, e3, Ut(e3.value.mapValue), We.exists(true)));
        }
        return n2.In.addMutationBatch(t5, s2, o, e2);
      })).then((t5) => (t5.applyToLocalDocumentSet(r), {
        batchId: t5.batchId,
        changes: r
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.Lo[t4.currentUser.toKey()];
      s2 || (s2 = new dn(tt));
      s2 = s2.insert(e2, n2), t4.Lo[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await ya2(s, t3.changes), await Eo(s.remoteStore);
  } catch (t3) {
    const e2 = xo(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function ra2(t2, e) {
  const n = U2(t2);
  try {
    const t3 = await fr(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.Fo.get(e2);
      s && (L2(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.Co = true : t4.modifiedDocuments.size > 0 ? L2(s.Co) : t4.removedDocuments.size > 0 && (L2(s.Co), s.Co = false));
    }), await ya2(n, t3, e);
  } catch (t3) {
    await Oi(t3);
  }
}
function oa2(t2, e, n) {
  const s = U2(t2);
  if (s.isPrimaryClient && n === 0 || !s.isPrimaryClient && n === 1) {
    const t3 = [];
    s.xo.forEach((n2, s2) => {
      const i = s2.view.eo(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = U2(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.eo(e2) && (s2 = true);
      }), s2 && Ko(n2);
    }(s.eventManager, e), t3.length && s.No.Tr(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function aa2(t2, e, n) {
  const s = U2(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.Fo.get(e), r = i && i.key;
  if (r) {
    let t3 = new dn(Pt.comparator);
    t3 = t3.insert(r, qt.newNoDocument(r, it.min()));
    const n2 = Pn().add(r), i2 = new Vn(it.min(), new Map(), new mn(tt), t3, n2);
    await ra2(s, i2), s.Oo = s.Oo.remove(r), s.Fo.delete(e), ga(s);
  } else
    await mr(s.localStore, e, false).then(() => da2(s, e, n)).catch(Oi);
}
async function ca(t2, e) {
  const n = U2(t2), s = e.batch.batchId;
  try {
    const t3 = await hr(n.localStore, e);
    fa2(n, s, null), la2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await ya2(n, t3);
  } catch (t3) {
    await Oi(t3);
  }
}
async function ua2(t2, e, n) {
  const s = U2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = U2(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.In.lookupMutationBatch(t5, e2).next((e3) => (L2(e3 !== null), s2 = e3.keys(), n2.In.removeMutationBatch(t5, e3))).next(() => n2.In.performConsistencyCheck(t5)).next(() => n2.Qn.bn(t5, s2));
      });
    }(s.localStore, e);
    fa2(s, e, n), la2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await ya2(s, t3);
  } catch (n2) {
    await Oi(n2);
  }
}
async function ha2(t2, e) {
  const n = U2(t2);
  fo(n.remoteStore) || k2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = U2(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.In.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (t3 === -1)
      return void e.resolve();
    const s = n.Bo.get(t3) || [];
    s.push(e), n.Bo.set(t3, s);
  } catch (t3) {
    const n2 = xo(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function la2(t2, e) {
  (t2.Bo.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.Bo.delete(e);
}
function fa2(t2, e, n) {
  const s = U2(t2);
  let i = s.Lo[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.Lo[s.currentUser.toKey()] = i;
  }
}
function da2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ko.get(e))
    t2.xo.delete(s), n && t2.No.jo(s, n);
  if (t2.ko.delete(e), t2.isPrimaryClient) {
    t2.Mo.cs(e).forEach((e2) => {
      t2.Mo.containsKey(e2) || wa(t2, e2);
    });
  }
}
function wa(t2, e) {
  t2.$o.delete(e.path.canonicalString());
  const n = t2.Oo.get(e);
  n !== null && (ao(t2.remoteStore, n), t2.Oo = t2.Oo.remove(e), t2.Fo.delete(n), ga(t2));
}
function _a(t2, e, n) {
  for (const s of n)
    if (s instanceof Ho)
      t2.Mo.addReference(s.key, e), ma2(t2, s);
    else if (s instanceof Jo) {
      k2("SyncEngine", "Document no longer in limbo: " + s.key), t2.Mo.removeReference(s.key, e);
      t2.Mo.containsKey(s.key) || wa(t2, s.key);
    } else
      M2();
}
function ma2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.Oo.get(n) || t2.$o.has(s) || (k2("SyncEngine", "New document in limbo: " + n), t2.$o.add(s), ga(t2));
}
function ga(t2) {
  for (; t2.$o.size > 0 && t2.Oo.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.$o.values().next().value;
    t2.$o.delete(e);
    const n = new Pt(ut.fromString(e)), s = t2.Uo.next();
    t2.Fo.set(s, new Zo(n)), t2.Oo = t2.Oo.insert(n, s), oo(t2.remoteStore, new si(Ee(de(n.path)), s, 2, Y2.T));
  }
}
async function ya2(t2, e, n) {
  const s = U2(t2), i = [], r = [], o = [];
  s.xo.isEmpty() || (s.xo.forEach((t3, a) => {
    o.push(s.Ko(a, e, n).then((t4) => {
      if (t4) {
        s.isPrimaryClient && s.sharedClientState.updateQueryState(a.targetId, t4.fromCache ? "not-current" : "current"), i.push(t4);
        const e2 = rr.kn(a.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.No.Tr(i), await async function(t3, e2) {
    const n2 = U2(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => Ks.forEach(e2, (e3) => Ks.forEach(e3.Nn, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => Ks.forEach(e3.xn, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!zs(t4))
        throw t4;
      k2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Un.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.Un = n2.Un.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function pa2(t2, e) {
  const n = U2(t2);
  if (!n.currentUser.isEqual(e)) {
    k2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await ur(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.Bo.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new K2(q2.CANCELLED, e2));
        });
      }), t4.Bo.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await ya2(n, t3.Wn);
  }
}
function Ea(t2, e) {
  const n = U2(t2), s = n.Fo.get(e);
  if (s && s.Co)
    return Pn().add(s.key);
  {
    let t3 = Pn();
    const s2 = n.ko.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.xo.get(e2);
      t3 = t3.unionWith(s3.view.To);
    }
    return t3;
  }
}
async function Ta(t2, e) {
  const n = U2(t2), s = await gr(n.localStore, e.query, true), i = e.view.So(s);
  return n.isPrimaryClient && _a(n, e.targetId, i.vo), i;
}
async function Ia2(t2) {
  const e = U2(t2);
  return pr(e.localStore).then((t3) => ya2(e, t3));
}
async function Aa2(t2, e, n, s) {
  const i = U2(t2), r = await function(t3, e2) {
    const n2 = U2(t3), s2 = U2(n2.In);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.Xt(t4, e2).next((e3) => e3 ? n2.Qn.bn(t4, e3) : Ks.resolve(null)));
  }(i.localStore, e);
  r !== null ? (n === "pending" ? await Eo(i.remoteStore) : n === "acknowledged" || n === "rejected" ? (fa2(i, e, s || null), la2(i, e), function(t3, e2) {
    U2(U2(t3).In).te(e2);
  }(i.localStore, e)) : M2(), await ya2(i, r)) : k2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function Ra2(t2, e) {
  const n = U2(t2);
  if (Da(n), Ca2(n), e === true && n.qo !== true) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await Pa(n, t3.toArray());
    n.qo = true, await So(n.remoteStore, true);
    for (const t4 of e2)
      oo(n.remoteStore, t4);
  } else if (e === false && n.qo !== false) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ko.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (da2(n, i), mr(n.localStore, i, true))), ao(n.remoteStore, i);
    }), await e2, await Pa(n, t3), function(t4) {
      const e3 = U2(t4);
      e3.Fo.forEach((t5, n2) => {
        ao(e3.remoteStore, n2);
      }), e3.Mo.us(), e3.Fo = new Map(), e3.Oo = new dn(Pt.comparator);
    }(n), n.qo = false, await So(n.remoteStore, false);
  }
}
async function Pa(t2, e, n) {
  const s = U2(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ko.get(t3);
    if (n2 && n2.length !== 0) {
      e2 = await _r(s.localStore, Ee(n2[0]));
      for (const t4 of n2) {
        const e3 = s.xo.get(t4), n3 = await Ta(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await yr(s.localStore, t3);
      e2 = await _r(s.localStore, n3), await na2(s, ba2(n3), t3, false);
    }
    i.push(e2);
  }
  return s.No.Tr(r), i;
}
function ba2(t2) {
  return fe(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function va(t2) {
  const e = U2(t2);
  return U2(U2(e.localStore).persistence).pn();
}
async function Va2(t2, e, n, s) {
  const i = U2(t2);
  if (i.qo)
    k2("SyncEngine", "Ignoring unexpected query state notification.");
  else if (i.ko.has(e))
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await pr(i.localStore), s2 = Vn.createSynthesizedRemoteEventForCurrentChange(e, n === "current");
        await ya2(i, t3, s2);
        break;
      }
      case "rejected":
        await mr(i.localStore, e, true), da2(i, e, s);
        break;
      default:
        M2();
    }
}
async function Sa2(t2, e, n) {
  const s = Da(t2);
  if (s.qo) {
    for (const t3 of e) {
      if (s.ko.has(t3)) {
        k2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await yr(s.localStore, t3), n2 = await _r(s.localStore, e2);
      await na2(s, ba2(e2), n2.targetId, false), oo(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ko.has(t3) && await mr(s.localStore, t3, false).then(() => {
        ao(s.remoteStore, t3), da2(s, t3);
      }).catch(Oi);
  }
}
function Da(t2) {
  const e = U2(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = ra2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Ea.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = aa2.bind(null, e), e.No.Tr = Uo.bind(null, e.eventManager), e.No.jo = qo.bind(null, e.eventManager), e;
}
function Ca2(t2) {
  const e = U2(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = ca.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = ua2.bind(null, e), e;
}
function Na2(t2, e, n) {
  const s = U2(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = U2(t4), s3 = Kn(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.Je.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), void n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2));
      n2._updateProgress(zo(s2));
      const i = new Go(s2, t3.localStore, e2.N);
      let r = await e2.Qo();
      for (; r; ) {
        const t4 = await i.fo(r);
        t4 && n2._updateProgress(t4), r = await e2.Qo();
      }
      const o = await i.complete();
      await ya2(t3, o.Tn, void 0), await function(t4, e3) {
        const n3 = U2(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.Je.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress);
    } catch (t4) {
      O2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4);
    }
  })(s, e, n).then(() => {
    s.sharedClientState.notifyBundleLoaded();
  });
}
var xa2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.N = Jr(t2.databaseInfo.databaseId), this.sharedClientState = this.Wo(t2), this.persistence = this.Go(t2), await this.persistence.start(), this.gcScheduler = this.zo(t2), this.localStore = this.Ho(t2);
  }
  zo(t2) {
    return null;
  }
  Ho(t2) {
    return cr(this.persistence, new or(), t2.initialUser, this.N);
  }
  Go(t2) {
    return new Dr(Nr.Ns, this.N);
  }
  Wo(t2) {
    return new qr();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var ka2 = class extends xa2 {
  constructor(t2, e, n) {
    super(), this.Jo = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await Er(this.localStore), await this.Jo.initialize(this, t2), await Ca2(this.Jo.syncEngine), await Eo(this.Jo.remoteStore), await this.persistence.nn(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(this.localStore), Promise.resolve()));
  }
  Ho(t2) {
    return cr(this.persistence, new or(), t2.initialUser, this.N);
  }
  zo(t2) {
    const e = this.persistence.referenceDelegate.garbageCollector;
    return new Li(e, t2.asyncQueue);
  }
  Go(t2) {
    const e = nr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = this.cacheSizeBytes !== void 0 ? Ai.withCacheSize(this.cacheSizeBytes) : Ai.DEFAULT;
    return new Zi(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, zr(), Hr(), this.N, this.sharedClientState, !!this.forceOwnership);
  }
  Wo(t2) {
    return new qr();
  }
};
var $a2 = class extends ka2 {
  constructor(t2, e) {
    super(t2, e, false), this.Jo = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.Jo.syncEngine;
    this.sharedClientState instanceof Ur && (this.sharedClientState.syncEngine = {
      _i: Aa2.bind(null, e),
      mi: Va2.bind(null, e),
      gi: Sa2.bind(null, e),
      pn: va.bind(null, e),
      wi: Ia2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.nn(async (t3) => {
      await Ra2(this.Jo.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start(this.localStore) : t3 || this.gcScheduler.stop());
    });
  }
  Wo(t2) {
    const e = zr();
    if (!Ur.Pt(e))
      throw new K2(q2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = nr(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new Ur(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var Oa = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(e, !t2.synchronizeTabs), this.sharedClientState.onlineStateHandler = (t3) => oa2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = pa2.bind(null, this.syncEngine), await So(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new Mo();
  }
  createDatastore(t2) {
    const e = Jr(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new Gr(s));
    var s;
    return function(t3, e2, n2) {
      return new eo(t3, e2, n2);
    }(t2.credentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => oa2(this.syncEngine, t3, 0), r = jr.Pt() ? new jr() : new Kr(), new so(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const a = new ta2(t3, e2, n, s, i, r);
      return o && (a.qo = true), a;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = U2(t2);
      k2("RemoteStore", "RemoteStore shutting down."), e.Kr.add(5), await ro(e), e.Qr.shutdown(), e.Wr.set("Unknown");
    }(this.remoteStore);
  }
};
function Fa2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.reject("unimplemented")
  };
}
var Ma2 = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.Yo(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.Yo(this.observer.error, t2) : console.error("Uncaught Error in snapshot listener:", t2);
  }
  Xo() {
    this.muted = true;
  }
  Yo(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var La2 = class {
  constructor(t2, e) {
    this.Zo = t2, this.N = e, this.metadata = new j(), this.buffer = new Uint8Array(), this.ta = new TextDecoder("utf-8"), this.ea().then((t3) => {
      t3 && t3.ho() ? this.metadata.resolve(t3.payload.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(t3 == null ? void 0 : t3.payload)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Zo.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async Qo() {
    return await this.getMetadata(), this.ea();
  }
  async ea() {
    const t2 = await this.na();
    if (t2 === null)
      return null;
    const e = this.ta.decode(t2), n = Number(e);
    isNaN(n) && this.sa(`length string (${e}) is not valid number`);
    const s = await this.ia(n);
    return new Qo(JSON.parse(s), t2.length + n);
  }
  ra() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async na() {
    for (; this.ra() < 0; ) {
      if (await this.oa())
        break;
    }
    if (this.buffer.length === 0)
      return null;
    const t2 = this.ra();
    t2 < 0 && this.sa("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async ia(t2) {
    for (; this.buffer.length < t2; ) {
      await this.oa() && this.sa("Reached the end of bundle when more is expected.");
    }
    const e = this.ta.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  sa(t2) {
    throw this.Zo.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async oa() {
    const t2 = await this.Zo.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var Ba = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new K2(q2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = U2(t3), s = Jn(n.N) + "/documents", i = {
        documents: e2.map((t4) => Wn(n.N, t4))
      }, r = await n.Ki("BatchGetDocuments", s, i), o = new Map();
      r.forEach((t4) => {
        const e3 = ts(n.N, t4);
        o.set(e3.key.toString(), e3);
      });
      const a = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        L2(!!e3), a.push(e3);
      }), a;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new on(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = Pt.fromPath(e);
      this.mutations.push(new an(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = U2(t3), s = Jn(n.N) + "/documents", i = {
        writes: e.map((t4) => ns(n.N, t4))
      };
      await n.Li("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw M2();
      e = it.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new K2(q2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? We.updateTime(e) : We.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(it.min()))
        throw new K2(q2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return We.updateTime(e);
    }
    return We.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Ua2 = class {
  constructor(t2, e, n, s) {
    this.asyncQueue = t2, this.datastore = e, this.updateFunction = n, this.deferred = s, this.aa = 5, this.rr = new Yr(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.aa -= 1, this.ca();
  }
  ca() {
    this.rr.Xi(async () => {
      const t2 = new Ba(this.datastore), e = this.ua(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.ha(t3);
        }));
      }).catch((t3) => {
        this.ha(t3);
      });
    });
  }
  ua(t2) {
    try {
      const e = this.updateFunction(t2);
      return !It(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  ha(t2) {
    this.aa > 0 && this.la(t2) ? (this.aa -= 1, this.asyncQueue.enqueueAndForget(() => (this.ca(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  la(t2) {
    if (t2.name === "FirebaseError") {
      const e = t2.code;
      return e === "aborted" || e === "failed-precondition" || !ln(e);
    }
    return false;
  }
};
var qa2 = class {
  constructor(t2, e, n) {
    this.credentials = t2, this.asyncQueue = e, this.databaseInfo = n, this.user = S2.UNAUTHENTICATED, this.clientId = Z2.I(), this.credentialListener = () => Promise.resolve(), this.credentials.start(e, async (t3) => {
      k2("FirestoreClient", "Received user=", t3.uid), await this.credentialListener(t3), this.user = t3;
    });
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      credentials: this.credentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.credentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new K2(q2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new j();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this.onlineComponents && await this.onlineComponents.terminate(), this.offlineComponents && await this.offlineComponents.terminate(), this.credentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = xo(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Ka2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), k2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await ur(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2.offlineComponents = e;
}
async function ja2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await Qa(t2);
  k2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => async function(t4, e2) {
    const n2 = U2(t4);
    n2.asyncQueue.verifyOperationInProgress(), k2("RemoteStore", "RemoteStore received new credentials");
    const s2 = fo(n2);
    n2.Kr.add(3), await ro(n2), s2 && n2.Wr.set("Unknown"), await n2.remoteSyncer.handleCredentialChange(e2), n2.Kr.delete(3), await io(n2);
  }(e.remoteStore, t3)), t2.onlineComponents = e;
}
async function Qa(t2) {
  return t2.offlineComponents || (k2("FirestoreClient", "Using default OfflineComponentProvider"), await Ka2(t2, new xa2())), t2.offlineComponents;
}
async function Wa2(t2) {
  return t2.onlineComponents || (k2("FirestoreClient", "Using default OnlineComponentProvider"), await ja2(t2, new Oa())), t2.onlineComponents;
}
function Ga2(t2) {
  return Qa(t2).then((t3) => t3.persistence);
}
function za2(t2) {
  return Qa(t2).then((t3) => t3.localStore);
}
function Ha2(t2) {
  return Wa2(t2).then((t3) => t3.remoteStore);
}
function Ja2(t2) {
  return Wa2(t2).then((t3) => t3.syncEngine);
}
async function Ya2(t2) {
  const e = await Wa2(t2), n = e.eventManager;
  return n.onListen = ea2.bind(null, e.syncEngine), n.onUnlisten = sa2.bind(null, e.syncEngine), n;
}
function Xa2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Ga2(t2), n = await Ha2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = U2(t3);
      return e2.Kr.delete(0), io(e2);
    }(n);
  });
}
function Za2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Ga2(t2), n = await Ha2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = U2(t3);
      e2.Kr.add(0), await ro(e2), e2.Wr.set("Offline");
    }(n);
  });
}
function tc2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = U2(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.Qn.An(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new K2(q2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = xo(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await za2(t2), e, n)), n.promise;
}
function ec2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ma2({
      next: (r2) => {
        e2.enqueueAndForget(() => Bo(t3, o));
        const a = r2.docs.has(n2);
        !a && r2.fromCache ? i.reject(new K2(q2.UNAVAILABLE, "Failed to get document because the client is offline.")) : a && r2.fromCache && s2 && s2.source === "server" ? i.reject(new K2(q2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new jo(de(n2.path), r, {
      includeMetadataChanges: true,
      uo: true
    });
    return Lo(t3, o);
  }(await Ya2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function nc2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await gr(t3, e2, true), i = new Yo(e2, s.Gn), r = i.Io(s.documents), o = i.applyChanges(r, false);
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = xo(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await za2(t2), e, n)), n.promise;
}
function sc2(t2, e, n = {}) {
  const s = new j();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new Ma2({
      next: (n3) => {
        e2.enqueueAndForget(() => Bo(t3, o)), n3.fromCache && s2.source === "server" ? i.reject(new K2(q2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new jo(n2, r, {
      includeMetadataChanges: true,
      uo: true
    });
    return Lo(t3, o);
  }(await Ya2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function ic2(t2, e) {
  const n = new Ma2(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    U2(t3).Zr.add(e2), e2.next();
  }(await Ya2(t2), n)), () => {
    n.Xo(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      U2(t3).Zr.delete(e2);
    }(await Ya2(t2), n));
  };
}
function rc2(t2, e) {
  const n = new j();
  return t2.asyncQueue.enqueueAndForget(async () => {
    const s = await function(t3) {
      return Wa2(t3).then((t4) => t4.datastore);
    }(t2);
    new Ua2(t2.asyncQueue, s, e, n).run();
  }), n.promise;
}
function oc2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = typeof t3 == "string" ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new La2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return Fa2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return Fa2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Jr(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    Na2(await Ja2(t2), i, s);
  });
}
function ac2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = U2(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.Je.getNamedQuery(t4, e2));
  }(await za2(t2), e));
}
var cc2 = class {
  constructor(t2, e, n, s, i, r, o, a) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = a;
  }
};
var uc2 = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  get isDefaultDatabase() {
    return this.database === "(default)";
  }
  isEqual(t2) {
    return t2 instanceof uc2 && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var hc2 = new Map();
function lc2(t2, e, n) {
  if (!n)
    throw new K2(q2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function fc2(t2, e, n, s) {
  if (e === true && s === true)
    throw new K2(q2.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function dc2(t2) {
  if (!Pt.isDocumentKey(t2))
    throw new K2(q2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function wc2(t2) {
  if (Pt.isDocumentKey(t2))
    throw new K2(q2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function _c(t2) {
  if (t2 === void 0)
    return "undefined";
  if (t2 === null)
    return "null";
  if (typeof t2 == "string")
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if (typeof t2 == "number" || typeof t2 == "boolean")
    return "" + t2;
  if (typeof t2 == "object") {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor) {
          const e2 = /function\s+([^\s(]+)\s*\(/.exec(t3.constructor.toString());
          if (e2 && e2.length > 1)
            return e2[1];
        }
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return typeof t2 == "function" ? "a function" : M2();
}
function mc2(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new K2(q2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = _c(t2);
      throw new K2(q2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function gc2(t2, e) {
  if (e <= 0)
    throw new K2(q2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var yc2 = class {
  constructor(t2) {
    var e;
    if (t2.host === void 0) {
      if (t2.ssl !== void 0)
        throw new K2(q2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = (e = t2.ssl) === null || e === void 0 || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, t2.cacheSizeBytes === void 0)
      this.cacheSizeBytes = 41943040;
    else {
      if (t2.cacheSizeBytes !== -1 && t2.cacheSizeBytes < 1048576)
        throw new K2(q2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, fc2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var pc2 = class {
  constructor(t2, e) {
    this._credentials = e, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new yc2({}), this._settingsFrozen = false, t2 instanceof uc2 ? this._databaseId = t2 : (this._app = t2, this._databaseId = function(t3) {
      if (!Object.prototype.hasOwnProperty.apply(t3.options, ["projectId"]))
        throw new K2(q2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new uc2(t3.options.projectId);
    }(t2));
  }
  get app() {
    if (!this._app)
      throw new K2(q2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return this._terminateTask !== void 0;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new K2(q2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new yc2(t2), t2.credentials !== void 0 && (this._credentials = function(t3) {
      if (!t3)
        return new W2();
      switch (t3.type) {
        case "gapi":
          const e = t3.client;
          return L2(!(typeof e != "object" || e === null || !e.auth || !e.auth.getAuthHeaderValueForFirstParty)), new J2(e, t3.sessionIndex || "0", t3.iamToken || null);
        case "provider":
          return t3.client;
        default:
          throw new K2(q2.INVALID_ARGUMENT, "makeCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = hc2.get(t2);
      e && (k2("ComponentProvider", "Removing Datastore"), hc2.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Ec2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = mc2(t2, pc2))._getSettings();
  if (r.host !== "firestore.googleapis.com" && r.host !== e && O2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if (typeof s.mockUserToken == "string")
      e2 = s.mockUserToken, n2 = S2.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, (i = t2._app) === null || i === void 0 ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new K2(q2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new S2(r2);
    }
    t2._credentials = new G(new Q2(e2, n2));
  }
}
var Tc2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new Ac2(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new Tc2(this.firestore, t2, this._key);
  }
};
var Ic2 = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new Ic2(this.firestore, t2, this._query);
  }
};
var Ac2 = class extends Ic2 {
  constructor(t2, e, n) {
    super(t2, e, de(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new Tc2(this.firestore, null, new Pt(t2));
  }
  withConverter(t2) {
    return new Ac2(this.firestore, t2, this._path);
  }
};
function Rc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), lc2("collection", "path", e), t2 instanceof pc2) {
    const s = ut.fromString(e, ...n);
    return wc2(s), new Ac2(t2, null, s);
  }
  {
    if (!(t2 instanceof Tc2 || t2 instanceof Ac2))
      throw new K2(q2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = ut.fromString(t2.path, ...n).child(ut.fromString(e));
    return wc2(s), new Ac2(t2.firestore, null, s);
  }
}
function Pc2(t2, e) {
  if (t2 = mc2(t2, pc2), lc2("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new K2(q2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new Ic2(t2, null, function(t3) {
    return new le(ut.emptyPath(), t3);
  }(e));
}
function bc2(t2, e, ...n) {
  if (t2 = getModularInstance(t2), arguments.length === 1 && (e = Z2.I()), lc2("doc", "path", e), t2 instanceof pc2) {
    const s = ut.fromString(e, ...n);
    return dc2(s), new Tc2(t2, null, new Pt(s));
  }
  {
    if (!(t2 instanceof Tc2 || t2 instanceof Ac2))
      throw new K2(q2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(ut.fromString(e, ...n));
    return dc2(s), new Tc2(t2.firestore, t2 instanceof Ac2 ? t2.converter : null, new Pt(s));
  }
}
function vc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof Tc2 || t2 instanceof Ac2) && (e instanceof Tc2 || e instanceof Ac2) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function Vc2(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof Ic2 && e instanceof Ic2 && (t2.firestore === e.firestore && Ie(t2._query, e._query) && t2.converter === e.converter);
}
var Sc2 = class {
  constructor() {
    this.fa = Promise.resolve(), this.da = [], this.wa = false, this._a = [], this.ma = null, this.ga = false, this.ya = false, this.pa = [], this.rr = new Yr(this, "async_queue_retry"), this.Ea = () => {
      const t3 = Hr();
      t3 && k2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.rr.tr();
    };
    const t2 = Hr();
    t2 && typeof t2.addEventListener == "function" && t2.addEventListener("visibilitychange", this.Ea);
  }
  get isShuttingDown() {
    return this.wa;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Ta(), this.Ia(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.wa) {
      this.wa = true, this.ya = t2 || false;
      const e = Hr();
      e && typeof e.removeEventListener == "function" && e.removeEventListener("visibilitychange", this.Ea);
    }
  }
  enqueue(t2) {
    if (this.Ta(), this.wa)
      return new Promise(() => {
      });
    const e = new j();
    return this.Ia(() => this.wa && this.ya ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.da.push(t2), this.Aa()));
  }
  async Aa() {
    if (this.da.length !== 0) {
      try {
        await this.da[0](), this.da.shift(), this.rr.reset();
      } catch (t2) {
        if (!zs(t2))
          throw t2;
        k2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.da.length > 0 && this.rr.Xi(() => this.Aa());
    }
  }
  Ia(t2) {
    const e = this.fa.then(() => (this.ga = true, t2().catch((t3) => {
      this.ma = t3, this.ga = false;
      throw $("INTERNAL UNHANDLED ERROR: ", function(t4) {
        let e2 = t4.message || "";
        t4.stack && (e2 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e2;
      }(t3)), t3;
    }).then((t3) => (this.ga = false, t3))));
    return this.fa = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Ta(), this.pa.indexOf(t2) > -1 && (e = 0);
    const s = No.createAndSchedule(this, t2, e, n, (t3) => this.Ra(t3));
    return this._a.push(s), s;
  }
  Ta() {
    this.ma && M2();
  }
  verifyOperationInProgress() {
  }
  async Pa() {
    let t2;
    do {
      t2 = this.fa, await t2;
    } while (t2 !== this.fa);
  }
  ba(t2) {
    for (const e of this._a)
      if (e.timerId === t2)
        return true;
    return false;
  }
  va(t2) {
    return this.Pa().then(() => {
      this._a.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this._a)
        if (e.skipDelay(), t2 !== "all" && e.timerId === t2)
          break;
      return this.Pa();
    });
  }
  Va(t2) {
    this.pa.push(t2);
  }
  Ra(t2) {
    const e = this._a.indexOf(t2);
    this._a.splice(e, 1);
  }
};
function Dc2(t2) {
  return function(t3, e) {
    if (typeof t3 != "object" || t3 === null)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && typeof n[t4] == "function")
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var Cc2 = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new j(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var Nc2 = -1;
var xc2 = class extends pc2 {
  constructor(t2, e) {
    super(t2, e), this.type = "firestore", this._queue = new Sc2(), this._persistenceKey = "name" in t2 ? t2.name : "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || Fc2(this), this._firestoreClient.terminate();
  }
};
function kc2(e, n) {
  const s = _getProvider(e, "firestore");
  if (s.isInitialized()) {
    const t2 = s.getImmediate(), e2 = s.getOptions();
    if (deepEqual(e2, n))
      return t2;
    throw new K2(q2.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (n.cacheSizeBytes !== void 0 && n.cacheSizeBytes !== -1 && n.cacheSizeBytes < 1048576)
    throw new K2(q2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return s.initialize({
    options: n
  });
}
function $c2(n = getApp()) {
  return _getProvider(n, "firestore").getImmediate();
}
function Oc2(t2) {
  return t2._firestoreClient || Fc2(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function Fc2(t2) {
  var e;
  const n = t2._freezeSettings(), s = function(t3, e2, n2, s2) {
    return new cc2(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, ((e = t2._app) === null || e === void 0 ? void 0 : e.options.appId) || "", t2._persistenceKey, n);
  t2._firestoreClient = new qa2(t2._credentials, t2._queue, s);
}
function Mc2(t2, e) {
  zc2(t2 = mc2(t2, xc2));
  const n = Oc2(t2), s = t2._freezeSettings(), i = new Oa();
  return Bc2(n, i, new ka2(i, s.cacheSizeBytes, e == null ? void 0 : e.forceOwnership));
}
function Lc2(t2) {
  zc2(t2 = mc2(t2, xc2));
  const e = Oc2(t2), n = t2._freezeSettings(), s = new Oa();
  return Bc2(e, s, new $a2(s, n.cacheSizeBytes));
}
function Bc2(t2, e, n) {
  const s = new j();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Ka2(t2, n), await ja2(t2, e), s.resolve();
    } catch (t3) {
      if (!function(t4) {
        if (t4.name === "FirebaseError")
          return t4.code === q2.FAILED_PRECONDITION || t4.code === q2.UNIMPLEMENTED;
        if (typeof DOMException != "undefined" && t4 instanceof DOMException)
          return t4.code === 22 || t4.code === 20 || t4.code === 11;
        return true;
      }(t3))
        throw t3;
      console.warn("Error enabling offline persistence. Falling back to persistence disabled: " + t3), s.reject(t3);
    }
  }).then(() => s.promise);
}
function Uc2(t2) {
  if (t2._initialized && !t2._terminated)
    throw new K2(q2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new j();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!Qs.Pt())
          return Promise.resolve();
        const e2 = t3 + "main";
        await Qs.delete(e2);
      }(nr(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function qc2(t2) {
  return function(t3) {
    const e = new j();
    return t3.asyncQueue.enqueueAndForget(async () => ha2(await Ja2(t3), e)), e.promise;
  }(Oc2(t2 = mc2(t2, xc2)));
}
function Kc2(t2) {
  return Xa2(Oc2(t2 = mc2(t2, xc2)));
}
function jc2(t2) {
  return Za2(Oc2(t2 = mc2(t2, xc2)));
}
function Qc2(t2) {
  return _removeServiceInstance(t2.app, "firestore"), t2._delete();
}
function Wc2(t2, e) {
  const n = Oc2(t2 = mc2(t2, xc2)), s = new Cc2();
  return oc2(n, t2._databaseId, e, s), s;
}
function Gc2(t2, e) {
  return ac2(Oc2(t2 = mc2(t2, xc2)), e).then((e2) => e2 ? new Ic2(t2, null, e2.query) : null);
}
function zc2(t2) {
  if (t2._initialized || t2._terminated)
    throw new K2(q2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Hc2 = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (t2[e].length === 0)
        throw new K2(q2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new lt(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function Jc2() {
  return new Hc2("__name__");
}
var Yc2 = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Yc2(wt.fromBase64String(t2));
    } catch (t3) {
      throw new K2(q2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Yc2(wt.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Xc2 = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var Zc2 = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new K2(q2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new K2(q2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return tt(this._lat, t2._lat) || tt(this._long, t2._long);
  }
};
var tu = /^__.*__$/;
var eu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return this.fieldMask !== null ? new en(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new tn(t2, this.data, e, this.fieldTransforms);
  }
};
var nu = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new en(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function su(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw M2();
  }
}
var iu = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.N = n, this.ignoreUndefinedProperties = s, i === void 0 && this.Sa(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Da() {
    return this.settings.Da;
  }
  Ca(t2) {
    return new iu(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.N, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Na(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Ca({
      path: n,
      xa: false
    });
    return s.ka(t2), s;
  }
  $a(t2) {
    var e;
    const n = (e = this.path) === null || e === void 0 ? void 0 : e.child(t2), s = this.Ca({
      path: n,
      xa: false
    });
    return s.Sa(), s;
  }
  Oa(t2) {
    return this.Ca({
      path: void 0,
      xa: true
    });
  }
  Fa(t2) {
    return Ru(t2, this.settings.methodName, this.settings.Ma || false, this.path, this.settings.La);
  }
  contains(t2) {
    return this.fieldMask.find((e) => t2.isPrefixOf(e)) !== void 0 || this.fieldTransforms.find((e) => t2.isPrefixOf(e.field)) !== void 0;
  }
  Sa() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.ka(this.path.get(t2));
  }
  ka(t2) {
    if (t2.length === 0)
      throw this.Fa("Document fields must not be empty");
    if (su(this.Da) && tu.test(t2))
      throw this.Fa('Document fields cannot begin and end with "__"');
  }
};
var ru = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.N = n || Jr(t2);
  }
  Ba(t2, e, n, s = false) {
    return new iu({
      Da: t2,
      methodName: e,
      La: n,
      path: lt.emptyPath(),
      xa: false,
      Ma: s
    }, this.databaseId, this.N, this.ignoreUndefinedProperties);
  }
};
function ou(t2) {
  const e = t2._freezeSettings(), n = Jr(t2._databaseId);
  return new ru(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function au(t2, e, n, s, i, r = {}) {
  const o = t2.Ba(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  Eu("Data must be an object, but it was:", o, s);
  const a = yu(s, o);
  let c, u;
  if (r.merge)
    c = new ft(o.fieldMask), u = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = Tu(e, s2, n);
      if (!o.contains(i2))
        throw new K2(q2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      Pu(t3, i2) || t3.push(i2);
    }
    c = new ft(t3), u = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, u = o.fieldTransforms;
  return new eu(new Bt(a), c, u);
}
var cu = class extends Xc2 {
  _toFieldTransform(t2) {
    if (t2.Da !== 2)
      throw t2.Da === 1 ? t2.Fa(`${this._methodName}() can only appear at the top level of your update data`) : t2.Fa(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof cu;
  }
};
function uu(t2, e, n) {
  return new iu({
    Da: 3,
    La: e.settings.La,
    methodName: t2._methodName,
    xa: n
  }, e.databaseId, e.N, e.ignoreUndefinedProperties);
}
var hu = class extends Xc2 {
  _toFieldTransform(t2) {
    return new Ke(t2.path, new $e());
  }
  isEqual(t2) {
    return t2 instanceof hu;
  }
};
var lu = class extends Xc2 {
  constructor(t2, e) {
    super(t2), this.Ua = e;
  }
  _toFieldTransform(t2) {
    const e = uu(this, t2, true), n = this.Ua.map((t3) => gu(t3, e)), s = new Oe(n);
    return new Ke(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var fu = class extends Xc2 {
  constructor(t2, e) {
    super(t2), this.Ua = e;
  }
  _toFieldTransform(t2) {
    const e = uu(this, t2, true), n = this.Ua.map((t3) => gu(t3, e)), s = new Me(n);
    return new Ke(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var du = class extends Xc2 {
  constructor(t2, e) {
    super(t2), this.qa = e;
  }
  _toFieldTransform(t2) {
    const e = new Be(t2.N, De(t2.N, this.qa));
    return new Ke(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function wu(t2, e, n, s) {
  const i = t2.Ba(1, e, n);
  Eu("Data must be an object, but it was:", i, s);
  const r = [], o = Bt.empty();
  ot(s, (t3, s2) => {
    const a2 = Au(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.$a(a2);
    if (s2 instanceof cu)
      r.push(a2);
    else {
      const t4 = gu(s2, c);
      t4 != null && (r.push(a2), o.set(a2, t4));
    }
  });
  const a = new ft(r);
  return new nu(o, a, i.fieldTransforms);
}
function _u(t2, e, n, s, i, r) {
  const o = t2.Ba(1, e, n), a = [Tu(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new K2(q2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    a.push(Tu(e, r[t3])), c.push(r[t3 + 1]);
  const u = [], h = Bt.empty();
  for (let t3 = a.length - 1; t3 >= 0; --t3)
    if (!Pu(u, a[t3])) {
      const e2 = a[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.$a(e2);
      if (n2 instanceof cu)
        u.push(e2);
      else {
        const t4 = gu(n2, s2);
        t4 != null && (u.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new ft(u);
  return new nu(h, l2, o.fieldTransforms);
}
function mu(t2, e, n, s = false) {
  return gu(n, t2.Ba(s ? 4 : 3, e));
}
function gu(t2, e) {
  if (pu(t2 = getModularInstance(t2)))
    return Eu("Unsupported field value:", e, t2), yu(t2, e);
  if (t2 instanceof Xc2)
    return function(t3, e2) {
      if (!su(e2.Da))
        throw e2.Fa(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.Fa(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (t2 === void 0 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.xa && e.Da !== 4)
      throw e.Fa("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = gu(i, e2.Oa(s));
        t4 == null && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if ((t3 = getModularInstance(t3)) === null)
      return {
        nullValue: "NULL_VALUE"
      };
    if (typeof t3 == "number")
      return De(e2.N, t3);
    if (typeof t3 == "boolean")
      return {
        booleanValue: t3
      };
    if (typeof t3 == "string")
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = st.fromDate(t3);
      return {
        timestampValue: Bn(e2.N, n)
      };
    }
    if (t3 instanceof st) {
      const n = new st(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Bn(e2.N, n)
      };
    }
    if (t3 instanceof Zc2)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Yc2)
      return {
        bytesValue: Un(e2.N, t3._byteString)
      };
    if (t3 instanceof Tc2) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.Fa(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: jn(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.Fa(`Unsupported field value: ${_c(t3)}`);
  }(t2, e);
}
function yu(t2, e) {
  const n = {};
  return at(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : ot(t2, (t3, s) => {
    const i = gu(s, e.Na(t3));
    i != null && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function pu(t2) {
  return !(typeof t2 != "object" || t2 === null || t2 instanceof Array || t2 instanceof Date || t2 instanceof st || t2 instanceof Zc2 || t2 instanceof Yc2 || t2 instanceof Tc2 || t2 instanceof Xc2);
}
function Eu(t2, e, n) {
  if (!pu(n) || !function(t3) {
    return typeof t3 == "object" && t3 !== null && (Object.getPrototypeOf(t3) === Object.prototype || Object.getPrototypeOf(t3) === null);
  }(n)) {
    const s = _c(n);
    throw s === "an object" ? e.Fa(t2 + " a custom object") : e.Fa(t2 + " " + s);
  }
}
function Tu(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Hc2)
    return e._internalPath;
  if (typeof e == "string")
    return Au(t2, e);
  throw Ru("Field path arguments must be of type string or FieldPath.", t2, false, void 0, n);
}
var Iu = new RegExp("[~\\*/\\[\\]]");
function Au(t2, e, n) {
  if (e.search(Iu) >= 0)
    throw Ru(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, t2, false, void 0, n);
  try {
    return new Hc2(...e.split("."))._internalPath;
  } catch (s) {
    throw Ru(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, t2, false, void 0, n);
  }
}
function Ru(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = i !== void 0;
  let a = `Function ${e}() called with invalid data`;
  n && (a += " (via `toFirestore()`)"), a += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new K2(q2.INVALID_ARGUMENT, a + t2 + c);
}
function Pu(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var bu = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new Tc2(this._firestore, this._converter, this._key);
  }
  exists() {
    return this._document !== null;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new vu(this._firestore, this._userDataWriter, this._key, this._document, null);
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(Vu("DocumentSnapshot.get", t2));
      if (e !== null)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var vu = class extends bu {
  data() {
    return super.data();
  }
};
function Vu(t2, e) {
  return typeof e == "string" ? Au(t2, e) : e instanceof Hc2 ? e._internalPath : e._delegate._internalPath;
}
var Su = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Du = class extends bu {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new Cu(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null);
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(Vu("DocumentSnapshot.get", t2));
      if (n !== null)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var Cu = class extends Du {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var Nu = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Su(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return this.size === 0;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new Cu(this._firestore, this._userDataWriter, n.key, n, new Su(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new K2(q2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => ({
          type: "added",
          doc: new Cu(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Su(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter),
          oldIndex: -1,
          newIndex: e3++
        }));
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || t4.type !== 3).map((e3) => {
          const s = new Cu(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Su(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return e3.type !== 0 && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), e3.type !== 1 && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: xu(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function xu(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return M2();
  }
}
function ku(t2, e) {
  return t2 instanceof Du && e instanceof Du ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (t2._document === null ? e._document === null : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof Nu && e instanceof Nu && (t2._firestore === e._firestore && Vc2(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function $u(t2) {
  if (_e(t2) && t2.explicitOrderBy.length === 0)
    throw new K2(q2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var Ou = class {
};
function Fu(t2, ...e) {
  for (const n of e)
    t2 = n._apply(t2);
  return t2;
}
var Mu = class extends Ou {
  constructor(t2, e, n) {
    super(), this.Ka = t2, this.ja = e, this.Qa = n, this.type = "where";
  }
  _apply(t2) {
    const e = ou(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let a;
      if (i.isKeyField()) {
        if (r === "array-contains" || r === "array-contains-any")
          throw new K2(q2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on FieldPath.documentId().`);
        if (r === "in" || r === "not-in") {
          Zu(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Xu(s, t3, n3));
          a = {
            arrayValue: {
              values: e3
            }
          };
        } else
          a = Xu(s, t3, o);
      } else
        r !== "in" && r !== "not-in" && r !== "array-contains-any" || Zu(o, r), a = mu(n2, e2, o, r === "in" || r === "not-in");
      const c = Ht.create(i, r, a);
      return function(t4, e3) {
        if (e3.v()) {
          const n4 = ge(t4);
          if (n4 !== null && !n4.isEqual(e3.field))
            throw new K2(q2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n4.toString()}' and '${e3.field.toString()}'`);
          const s2 = me(t4);
          s2 !== null && th(t4, e3.field, s2);
        }
        const n3 = function(t5, e4) {
          for (const n4 of t5.filters)
            if (e4.indexOf(n4.op) >= 0)
              return n4.op;
          return null;
        }(t4, function(t5) {
          switch (t5) {
            case "!=":
              return ["!=", "not-in"];
            case "array-contains":
              return ["array-contains", "array-contains-any", "not-in"];
            case "in":
              return ["array-contains-any", "in", "not-in"];
            case "array-contains-any":
              return ["array-contains", "array-contains-any", "in", "not-in"];
            case "not-in":
              return ["array-contains", "array-contains-any", "in", "not-in", "!="];
            default:
              return [];
          }
        }(e3.op));
        if (n3 !== null)
          throw n3 === e3.op ? new K2(q2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e3.op.toString()}' filter.`) : new K2(q2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e3.op.toString()}' filters with '${n3.toString()}' filters.`);
      }(t3, c), c;
    }(t2._query, "where", e, t2.firestore._databaseId, this.Ka, this.ja, this.Qa);
    return new Ic2(t2.firestore, t2.converter, function(t3, e2) {
      const n2 = t3.filters.concat([e2]);
      return new le(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), n2, t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, n));
  }
};
function Lu(t2, e, n) {
  const s = e, i = Vu("where", t2);
  return new Mu(i, s, n);
}
var Bu = class extends Ou {
  constructor(t2, e) {
    super(), this.Ka = t2, this.Wa = e, this.type = "orderBy";
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (t3.startAt !== null)
        throw new K2(q2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (t3.endAt !== null)
        throw new K2(q2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new ae(e2, n);
      return function(t4, e3) {
        if (me(t4) === null) {
          const n2 = ge(t4);
          n2 !== null && th(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this.Ka, this.Wa);
    return new Ic2(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new le(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Uu(t2, e = "asc") {
  const n = e, s = Vu("orderBy", t2);
  return new Bu(s, n);
}
var qu = class extends Ou {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ga = e, this.za = n;
  }
  _apply(t2) {
    return new Ic2(t2.firestore, t2.converter, Te(t2._query, this.Ga, this.za));
  }
};
function Ku(t2) {
  return gc2("limit", t2), new qu("limit", t2, "F");
}
function ju(t2) {
  return gc2("limitToLast", t2), new qu("limitToLast", t2, "L");
}
var Qu = class extends Ou {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ha = e, this.Ja = n;
  }
  _apply(t2) {
    const e = Yu(t2, this.type, this.Ha, this.Ja);
    return new Ic2(t2.firestore, t2.converter, function(t3, e2) {
      return new le(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function Wu(...t2) {
  return new Qu("startAt", t2, true);
}
function Gu(...t2) {
  return new Qu("startAfter", t2, false);
}
var zu = class extends Ou {
  constructor(t2, e, n) {
    super(), this.type = t2, this.Ha = e, this.Ja = n;
  }
  _apply(t2) {
    const e = Yu(t2, this.type, this.Ha, this.Ja);
    return new Ic2(t2.firestore, t2.converter, function(t3, e2) {
      return new le(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Hu(...t2) {
  return new zu("endBefore", t2, true);
}
function Ju(...t2) {
  return new zu("endAt", t2, false);
}
function Yu(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof bu)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new K2(q2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of pe(t3))
        if (n3.field.isKeyField())
          r.push(xt(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (pt(t4))
            throw new K2(q2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (t4 === null) {
            const t5 = n3.field.canonicalString();
            throw new K2(q2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new re(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = ou(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new K2(q2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const a = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if (typeof c != "string")
            throw new K2(q2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!ye(t3) && c.indexOf("/") !== -1)
            throw new K2(q2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by FieldPath.documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(ut.fromString(c));
          if (!Pt.isDocumentKey(n3))
            throw new K2(q2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by FieldPath.documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new Pt(n3);
          a.push(xt(e2, i3));
        } else {
          const t4 = mu(n2, s2, c);
          a.push(t4);
        }
      }
      return new re(a, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Xu(t2, e, n) {
  if (typeof (n = getModularInstance(n)) == "string") {
    if (n === "")
      throw new K2(q2.INVALID_ARGUMENT, "Invalid query. When querying with FieldPath.documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!ye(e) && n.indexOf("/") !== -1)
      throw new K2(q2.INVALID_ARGUMENT, `Invalid query. When querying a collection by FieldPath.documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(ut.fromString(n));
    if (!Pt.isDocumentKey(s))
      throw new K2(q2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by FieldPath.documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return xt(t2, new Pt(s));
  }
  if (n instanceof Tc2)
    return xt(t2, n._key);
  throw new K2(q2.INVALID_ARGUMENT, `Invalid query. When querying with FieldPath.documentId(), you must provide a valid string or a DocumentReference, but it was: ${_c(n)}.`);
}
function Zu(t2, e) {
  if (!Array.isArray(t2) || t2.length === 0)
    throw new K2(q2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
  if (t2.length > 10)
    throw new K2(q2.INVALID_ARGUMENT, `Invalid Query. '${e.toString()}' filters support a maximum of 10 elements in the value array.`);
}
function th(t2, e, n) {
  if (!n.isEqual(e))
    throw new K2(q2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
var eh = class {
  convertValue(t2, e = "none") {
    switch (bt(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return gt(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(yt(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw M2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return ot(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new Zc2(gt(t2.latitude), gt(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = Et(t2);
        return n == null ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Tt(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = mt(t2);
    return new st(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = ut.fromString(t2);
    L2(ps(n));
    const s = new uc2(n.get(1), n.get(3)), i = new Pt(n.popFirst(5));
    return s.isEqual(e) || $(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function nh(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var sh = class extends eh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Yc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Tc2(this.firestore, null, e);
  }
};
var ih = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = ou(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = rh(t2, this._firestore), i = nh(s.converter, e, n), r = au(this._dataReader, "WriteBatch.set", s._key, i, s.converter !== null, n);
    return this._mutations.push(r.toMutation(s._key, We.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = rh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Hc2 ? _u(this._dataReader, "WriteBatch.update", i._key, e, n, s) : wu(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, We.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = rh(t2, this._firestore);
    return this._mutations = this._mutations.concat(new on(e._key, We.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new K2(q2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function rh(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new K2(q2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
function oh(t2) {
  t2 = mc2(t2, Tc2);
  const e = mc2(t2.firestore, xc2);
  return ec2(Oc2(e), t2._key).then((n) => Eh(e, t2, n));
}
var ah = class extends eh {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Yc2(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new Tc2(this.firestore, null, e);
  }
};
function ch(t2) {
  t2 = mc2(t2, Tc2);
  const e = mc2(t2.firestore, xc2), n = Oc2(e), s = new ah(e);
  return tc2(n, t2._key).then((n2) => new Du(e, s, t2._key, n2, new Su(n2 !== null && n2.hasLocalMutations, true), t2.converter));
}
function uh(t2) {
  t2 = mc2(t2, Tc2);
  const e = mc2(t2.firestore, xc2);
  return ec2(Oc2(e), t2._key, {
    source: "server"
  }).then((n) => Eh(e, t2, n));
}
function hh(t2) {
  t2 = mc2(t2, Ic2);
  const e = mc2(t2.firestore, xc2), n = Oc2(e), s = new ah(e);
  return $u(t2._query), sc2(n, t2._query).then((n2) => new Nu(e, s, t2, n2));
}
function lh(t2) {
  t2 = mc2(t2, Ic2);
  const e = mc2(t2.firestore, xc2), n = Oc2(e), s = new ah(e);
  return nc2(n, t2._query).then((n2) => new Nu(e, s, t2, n2));
}
function fh(t2) {
  t2 = mc2(t2, Ic2);
  const e = mc2(t2.firestore, xc2), n = Oc2(e), s = new ah(e);
  return sc2(n, t2._query, {
    source: "server"
  }).then((n2) => new Nu(e, s, t2, n2));
}
function dh(t2, e, n) {
  t2 = mc2(t2, Tc2);
  const s = mc2(t2.firestore, xc2), i = nh(t2.converter, e, n);
  return ph(s, [au(ou(s), "setDoc", t2._key, i, t2.converter !== null, n).toMutation(t2._key, We.none())]);
}
function wh(t2, e, n, ...s) {
  t2 = mc2(t2, Tc2);
  const i = mc2(t2.firestore, xc2), r = ou(i);
  let o;
  o = typeof (e = getModularInstance(e)) == "string" || e instanceof Hc2 ? _u(r, "updateDoc", t2._key, e, n, s) : wu(r, "updateDoc", t2._key, e);
  return ph(i, [o.toMutation(t2._key, We.exists(true))]);
}
function _h(t2) {
  return ph(mc2(t2.firestore, xc2), [new on(t2._key, We.none())]);
}
function mh(t2, e) {
  const n = mc2(t2.firestore, xc2), s = bc2(t2), i = nh(t2.converter, e);
  return ph(n, [au(ou(t2.firestore), "addDoc", s._key, i, t2.converter !== null, {}).toMutation(s._key, We.exists(false))]).then(() => s);
}
function gh(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  typeof e[o] != "object" || Dc2(e[o]) || (r = e[o], o++);
  const a = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (Dc2(e[o])) {
    const t3 = e[o];
    e[o] = (n = t3.next) === null || n === void 0 ? void 0 : n.bind(t3), e[o + 1] = (s = t3.error) === null || s === void 0 ? void 0 : s.bind(t3), e[o + 2] = (i = t3.complete) === null || i === void 0 ? void 0 : i.bind(t3);
  }
  let c, u, h;
  if (t2 instanceof Tc2)
    u = mc2(t2.firestore, xc2), h = de(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](Eh(u, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = mc2(t2, Ic2);
    u = mc2(n2.firestore, xc2), h = n2._query;
    const s2 = new ah(u);
    c = {
      next: (t3) => {
        e[o] && e[o](new Nu(u, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, $u(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new Ma2(s2), r2 = new jo(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => Lo(await Ya2(t3), r2)), () => {
      i2.Xo(), t3.asyncQueue.enqueueAndForget(async () => Bo(await Ya2(t3), r2));
    };
  }(Oc2(u), h, a, c);
}
function yh(t2, e) {
  return ic2(Oc2(t2 = mc2(t2, xc2)), Dc2(e) ? e : {
    next: e
  });
}
function ph(t2, e) {
  return function(t3, e2) {
    const n = new j();
    return t3.asyncQueue.enqueueAndForget(async () => ia2(await Ja2(t3), e2, n)), n.promise;
  }(Oc2(t2), e);
}
function Eh(t2, e, n) {
  const s = n.docs.get(e._key), i = new ah(t2);
  return new Du(t2, i, e._key, s, new Su(n.hasPendingWrites, n.fromCache), e.converter);
}
var Th = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = ou(t2);
  }
  get(t2) {
    const e = rh(t2, this._firestore), n = new sh(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || t3.length !== 1)
        return M2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new bu(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new bu(this._firestore, n, e._key, null, e.converter);
      throw M2();
    });
  }
  set(t2, e, n) {
    const s = rh(t2, this._firestore), i = nh(s.converter, e, n), r = au(this._dataReader, "Transaction.set", s._key, i, s.converter !== null, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = rh(t2, this._firestore);
    let r;
    return r = typeof (e = getModularInstance(e)) == "string" || e instanceof Hc2 ? _u(this._dataReader, "Transaction.update", i._key, e, n, s) : wu(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = rh(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = rh(t2, this._firestore), n = new ah(this._firestore);
    return super.get(t2).then((t3) => new Du(this._firestore, n, e._key, t3._document, new Su(false, false), e.converter));
  }
};
function Ih(t2, e) {
  return rc2(Oc2(t2), (n) => e(new Th(t2, n)));
}
function Ah() {
  return new cu("deleteField");
}
function Rh() {
  return new hu("serverTimestamp");
}
function Ph(...t2) {
  return new lu("arrayUnion", t2);
}
function bh(...t2) {
  return new fu("arrayRemove", t2);
}
function vh(t2) {
  return new du("increment", t2);
}
function Vh(t2) {
  return Oc2(t2 = mc2(t2, xc2)), new ih(t2, (e) => ph(t2, e));
}
var Sh;
!function(t2) {
  D2 = t2;
}(SDK_VERSION), _registerComponent(new Component("firestore", (t2, { options: e }) => {
  const n = t2.getProvider("app").getImmediate(), s = new xc2(n, new z2(t2.getProvider("auth-internal")));
  return e = Object.assign({
    useFetchStreams: true
  }, e), s._setSettings(e), s;
}, "PUBLIC")), registerVersion("@firebase/firestore", "3.0.1", Sh);
export {
  eh as AbstractUserDataWriter,
  Yc2 as Bytes,
  Nc2 as CACHE_SIZE_UNLIMITED,
  Ac2 as CollectionReference,
  Tc2 as DocumentReference,
  Du as DocumentSnapshot,
  Hc2 as FieldPath,
  Xc2 as FieldValue,
  xc2 as Firestore,
  K2 as FirestoreError,
  Zc2 as GeoPoint,
  Cc2 as LoadBundleTask,
  Ic2 as Query,
  Ou as QueryConstraint,
  Cu as QueryDocumentSnapshot,
  Nu as QuerySnapshot,
  Su as SnapshotMetadata,
  st as Timestamp,
  Th as Transaction,
  ih as WriteBatch,
  uc2 as _DatabaseId,
  Pt as _DocumentKey,
  lt as _FieldPath,
  mc2 as _cast,
  B2 as _debugAssert,
  dt as _isBase64Available,
  O2 as _logWarn,
  fc2 as _validateIsNotUsedTogether,
  mh as addDoc,
  bh as arrayRemove,
  Ph as arrayUnion,
  Uc2 as clearIndexedDbPersistence,
  Rc2 as collection,
  Pc2 as collectionGroup,
  Ec2 as connectFirestoreEmulator,
  _h as deleteDoc,
  Ah as deleteField,
  jc2 as disableNetwork,
  bc2 as doc,
  Jc2 as documentId,
  Mc2 as enableIndexedDbPersistence,
  Lc2 as enableMultiTabIndexedDbPersistence,
  Kc2 as enableNetwork,
  Ju as endAt,
  Hu as endBefore,
  Oc2 as ensureFirestoreConfigured,
  ph as executeWrite,
  oh as getDoc,
  ch as getDocFromCache,
  uh as getDocFromServer,
  hh as getDocs,
  lh as getDocsFromCache,
  fh as getDocsFromServer,
  $c2 as getFirestore,
  vh as increment,
  kc2 as initializeFirestore,
  Ku as limit,
  ju as limitToLast,
  Wc2 as loadBundle,
  Gc2 as namedQuery,
  gh as onSnapshot,
  yh as onSnapshotsInSync,
  Uu as orderBy,
  Fu as query,
  Vc2 as queryEqual,
  vc2 as refEqual,
  Ih as runTransaction,
  Rh as serverTimestamp,
  dh as setDoc,
  x2 as setLogLevel,
  ku as snapshotEqual,
  Gu as startAfter,
  Wu as startAt,
  Qc2 as terminate,
  wh as updateDoc,
  qc2 as waitForPendingWrites,
  Lu as where,
  Vh as writeBatch
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=@firebase_firestore.js.map
